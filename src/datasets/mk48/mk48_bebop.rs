//
// This code was generated by a tool.
//
//
//   bebopc version:
//       2.8.5
//
//
//   bebopc source:
//       https://github.com/RainwayApp/bebop
//
//
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.
//

#![allow(warnings)]

use bebop::FixedSized as _;
use core::convert::TryInto as _;
use std::io::Write as _;

#[repr(u32)]
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum EntityType {
    ArleighBurke = 1,
    Bismarck = 2,
    Clemenceau = 3,
    Fletcher = 4,
    G5 = 5,
    Iowa = 6,
    Kolkata = 7,
    Osa = 8,
    Yasen = 9,
    Zubr = 10,
}

impl ::core::convert::TryFrom<u32> for EntityType {
    type Error = ::bebop::DeserializeError;

    fn try_from(value: u32) -> ::bebop::DeResult<Self> {
        match value {
            1 => Ok(EntityType::ArleighBurke),
            2 => Ok(EntityType::Bismarck),
            3 => Ok(EntityType::Clemenceau),
            4 => Ok(EntityType::Fletcher),
            5 => Ok(EntityType::G5),
            6 => Ok(EntityType::Iowa),
            7 => Ok(EntityType::Kolkata),
            8 => Ok(EntityType::Osa),
            9 => Ok(EntityType::Yasen),
            10 => Ok(EntityType::Zubr),
            d => Err(::bebop::DeserializeError::InvalidEnumDiscriminator(
                d.into(),
            )),
        }
    }
}

impl ::core::convert::From<EntityType> for u32 {
    fn from(value: EntityType) -> Self {
        match value {
            EntityType::ArleighBurke => 1,
            EntityType::Bismarck => 2,
            EntityType::Clemenceau => 3,
            EntityType::Fletcher => 4,
            EntityType::G5 => 5,
            EntityType::Iowa => 6,
            EntityType::Kolkata => 7,
            EntityType::Osa => 8,
            EntityType::Yasen => 9,
            EntityType::Zubr => 10,
        }
    }
}

impl ::bebop::SubRecord<'_> for EntityType {
    const MIN_SERIALIZED_SIZE: usize = ::std::mem::size_of::<u32>();
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(::std::mem::size_of::<u32>());

    #[inline]
    fn serialized_size(&self) -> usize {
        ::std::mem::size_of::<u32>()
    }

    ::bebop::define_serialize_chained!(*Self => |zelf, dest| {
        u32::from(zelf)._serialize_chained(dest)
    });

    #[inline]
    fn _deserialize_chained(raw: &[u8]) -> ::bebop::DeResult<(usize, Self)> {
        let (n, v) = u32::_deserialize_chained(raw)?;
        Ok((n, v.try_into()?))
    }
}

impl ::bebop::FixedSized for EntityType {
    const SERIALIZED_SIZE: usize = ::std::mem::size_of::<u32>();
}

#[derive(Clone, Debug, PartialEq, Copy)]
#[repr(packed)]
pub struct Vector2F {
    pub x: f32,
    pub y: f32,
}

impl ::bebop::FixedSized for Vector2F {}

impl<'raw> ::bebop::SubRecord<'raw> for Vector2F {
    const MIN_SERIALIZED_SIZE: usize = Self::SERIALIZED_SIZE;
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(Self::SERIALIZED_SIZE);

    #[inline]
    fn serialized_size(&self) -> usize {
        Self::SERIALIZED_SIZE
    }

    ::bebop::define_serialize_chained!(*Self => |zelf, dest| {
        Ok(
            ::bebop::packed_read!(zelf.x)._serialize_chained(dest)? +
            ::bebop::packed_read!(zelf.y)._serialize_chained(dest)?
        )
    });

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((i, Self { x: v0, y: v1 }))
    }
}

impl<'raw> ::bebop::Record<'raw> for Vector2F {}

#[derive(Clone, Debug, PartialEq, Copy)]
#[repr(packed)]
pub struct Transform {
    pub altitude: i16,
    pub angle: u16,
    pub position: Vector2F,
    pub velocity: i16,
}

impl ::bebop::FixedSized for Transform {}

impl<'raw> ::bebop::SubRecord<'raw> for Transform {
    const MIN_SERIALIZED_SIZE: usize = Self::SERIALIZED_SIZE;
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(Self::SERIALIZED_SIZE);

    #[inline]
    fn serialized_size(&self) -> usize {
        Self::SERIALIZED_SIZE
    }

    ::bebop::define_serialize_chained!(*Self => |zelf, dest| {
        Ok(
            ::bebop::packed_read!(zelf.altitude)._serialize_chained(dest)? +
            ::bebop::packed_read!(zelf.angle)._serialize_chained(dest)? +
            ::bebop::packed_read!(zelf.position)._serialize_chained(dest)? +
            ::bebop::packed_read!(zelf.velocity)._serialize_chained(dest)?
        )
    });

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v2) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v3) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((
            i,
            Self {
                altitude: v0,
                angle: v1,
                position: v2,
                velocity: v3,
            },
        ))
    }
}

impl<'raw> ::bebop::Record<'raw> for Transform {}

#[derive(Clone, Debug, PartialEq, Copy)]
#[repr(packed)]
pub struct Guidance {
    pub angle: u16,
    pub submerge: bool,
    pub velocity: i16,
}

impl ::bebop::FixedSized for Guidance {}

impl<'raw> ::bebop::SubRecord<'raw> for Guidance {
    const MIN_SERIALIZED_SIZE: usize = Self::SERIALIZED_SIZE;
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(Self::SERIALIZED_SIZE);

    #[inline]
    fn serialized_size(&self) -> usize {
        Self::SERIALIZED_SIZE
    }

    ::bebop::define_serialize_chained!(*Self => |zelf, dest| {
        Ok(
            ::bebop::packed_read!(zelf.angle)._serialize_chained(dest)? +
            ::bebop::packed_read!(zelf.submerge)._serialize_chained(dest)? +
            ::bebop::packed_read!(zelf.velocity)._serialize_chained(dest)?
        )
    });

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v2) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((
            i,
            Self {
                angle: v0,
                submerge: v1,
                velocity: v2,
            },
        ))
    }
}

impl<'raw> ::bebop::Record<'raw> for Guidance {}

#[derive(Clone, Debug, PartialEq)]
pub struct Contact<'raw> {
    pub damage: u8,
    pub entity_id: u32,
    pub entity_type: EntityType,
    pub guidance: Guidance,
    pub player_id: u32,
    pub reloads: ::bebop::SliceWrapper<'raw, bool>,
    pub transform: Transform,
    pub turret_angles: ::bebop::SliceWrapper<'raw, u32>,
}

impl<'raw> ::bebop::SubRecord<'raw> for Contact<'raw> {
    const MIN_SERIALIZED_SIZE: usize = <u8>::MIN_SERIALIZED_SIZE
        + <u32>::MIN_SERIALIZED_SIZE
        + <EntityType>::MIN_SERIALIZED_SIZE
        + <Guidance>::MIN_SERIALIZED_SIZE
        + <u32>::MIN_SERIALIZED_SIZE
        + <::bebop::SliceWrapper<'raw, bool>>::MIN_SERIALIZED_SIZE
        + <Transform>::MIN_SERIALIZED_SIZE
        + <::bebop::SliceWrapper<'raw, u32>>::MIN_SERIALIZED_SIZE;

    #[inline]
    fn serialized_size(&self) -> usize {
        self.damage.serialized_size()
            + self.entity_id.serialized_size()
            + self.entity_type.serialized_size()
            + self.guidance.serialized_size()
            + self.player_id.serialized_size()
            + self.reloads.serialized_size()
            + self.transform.serialized_size()
            + self.turret_angles.serialized_size()
    }

    ::bebop::define_serialize_chained!(Self => |zelf, dest| {
        Ok(
            zelf.damage._serialize_chained(dest)? +
            zelf.entity_id._serialize_chained(dest)? +
            zelf.entity_type._serialize_chained(dest)? +
            zelf.guidance._serialize_chained(dest)? +
            zelf.player_id._serialize_chained(dest)? +
            zelf.reloads._serialize_chained(dest)? +
            zelf.transform._serialize_chained(dest)? +
            zelf.turret_angles._serialize_chained(dest)?
        )
    });

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v2) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v3) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v4) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v5) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v6) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v7) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((
            i,
            Self {
                damage: v0,
                entity_id: v1,
                entity_type: v2,
                guidance: v3,
                player_id: v4,
                reloads: v5,
                transform: v6,
                turret_angles: v7,
            },
        ))
    }
}

impl<'raw> ::bebop::Record<'raw> for Contact<'raw> {}

#[derive(Clone, Debug, PartialEq, Copy)]
#[repr(packed)]
pub struct ChunkId {
    pub x: i32,
    pub y: i32,
}

impl ::bebop::FixedSized for ChunkId {}

impl<'raw> ::bebop::SubRecord<'raw> for ChunkId {
    const MIN_SERIALIZED_SIZE: usize = Self::SERIALIZED_SIZE;
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(Self::SERIALIZED_SIZE);

    #[inline]
    fn serialized_size(&self) -> usize {
        Self::SERIALIZED_SIZE
    }

    ::bebop::define_serialize_chained!(*Self => |zelf, dest| {
        Ok(
            ::bebop::packed_read!(zelf.x)._serialize_chained(dest)? +
            ::bebop::packed_read!(zelf.y)._serialize_chained(dest)?
        )
    });

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((i, Self { x: v0, y: v1 }))
    }
}

impl<'raw> ::bebop::Record<'raw> for ChunkId {}

#[derive(Clone, Debug, PartialEq)]
pub struct TerrainUpdate<'raw> {
    pub chunk_id: ChunkId,
    pub data: ::bebop::SliceWrapper<'raw, u8>,
}

impl<'raw> ::bebop::SubRecord<'raw> for TerrainUpdate<'raw> {
    const MIN_SERIALIZED_SIZE: usize =
        <ChunkId>::MIN_SERIALIZED_SIZE + <::bebop::SliceWrapper<'raw, u8>>::MIN_SERIALIZED_SIZE;

    #[inline]
    fn serialized_size(&self) -> usize {
        self.chunk_id.serialized_size() + self.data.serialized_size()
    }

    ::bebop::define_serialize_chained!(Self => |zelf, dest| {
        Ok(
            zelf.chunk_id._serialize_chained(dest)? +
            zelf.data._serialize_chained(dest)?
        )
    });

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((
            i,
            Self {
                chunk_id: v0,
                data: v1,
            },
        ))
    }
}

impl<'raw> ::bebop::Record<'raw> for TerrainUpdate<'raw> {}

#[derive(Clone, Debug, PartialEq)]
pub struct Update<'raw> {
    pub contacts: ::std::vec::Vec<Contact<'raw>>,
    pub score: u32,
    pub world_radius: f32,
    pub terrain_updates: ::std::vec::Vec<TerrainUpdate<'raw>>,
}

impl<'raw> ::bebop::SubRecord<'raw> for Update<'raw> {
    const MIN_SERIALIZED_SIZE: usize = <::std::vec::Vec<Contact<'raw>>>::MIN_SERIALIZED_SIZE
        + <u32>::MIN_SERIALIZED_SIZE
        + <f32>::MIN_SERIALIZED_SIZE
        + <::std::vec::Vec<TerrainUpdate<'raw>>>::MIN_SERIALIZED_SIZE;

    #[inline]
    fn serialized_size(&self) -> usize {
        self.contacts.serialized_size()
            + self.score.serialized_size()
            + self.world_radius.serialized_size()
            + self.terrain_updates.serialized_size()
    }

    ::bebop::define_serialize_chained!(Self => |zelf, dest| {
        Ok(
            zelf.contacts._serialize_chained(dest)? +
            zelf.score._serialize_chained(dest)? +
            zelf.world_radius._serialize_chained(dest)? +
            zelf.terrain_updates._serialize_chained(dest)?
        )
    });

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v2) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v3) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((
            i,
            Self {
                contacts: v0,
                score: v1,
                world_radius: v2,
                terrain_updates: v3,
            },
        ))
    }
}

impl<'raw> ::bebop::Record<'raw> for Update<'raw> {}

#[derive(Clone, Debug, PartialEq)]
pub struct Updates<'raw> {
    pub updates_: ::std::vec::Vec<Update<'raw>>,
}

impl<'raw> ::bebop::SubRecord<'raw> for Updates<'raw> {
    const MIN_SERIALIZED_SIZE: usize = <::std::vec::Vec<Update<'raw>>>::MIN_SERIALIZED_SIZE;

    #[inline]
    fn serialized_size(&self) -> usize {
        self.updates_.serialized_size()
    }

    ::bebop::define_serialize_chained!(Self => |zelf, dest| {
        Ok(
            zelf.updates_._serialize_chained(dest)?
        )
    });

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((i, Self { updates_: v0 }))
    }
}

impl<'raw> ::bebop::Record<'raw> for Updates<'raw> {}

#[cfg(feature = "bebop-owned-all")]
pub mod owned {
    #![allow(warnings)]

    use bebop::FixedSized as _;
    use core::convert::TryInto as _;
    use std::io::Write as _;

    pub use super::EntityType;

    pub use super::Vector2F;

    pub use super::Transform;

    pub use super::Guidance;

    #[derive(Clone, Debug, PartialEq)]
    pub struct Contact {
        pub damage: u8,
        pub entity_id: u32,
        pub entity_type: EntityType,
        pub guidance: Guidance,
        pub player_id: u32,
        pub reloads: ::std::vec::Vec<bool>,
        pub transform: Transform,
        pub turret_angles: ::std::vec::Vec<u32>,
    }

    impl<'raw> ::core::convert::From<super::Contact<'raw>> for Contact {
        fn from(value: super::Contact) -> Self {
            Self {
                damage: value.damage,
                entity_id: value.entity_id,
                entity_type: value.entity_type,
                guidance: value.guidance,
                player_id: value.player_id,
                reloads: value.reloads.iter().map(|value| value).collect(),
                transform: value.transform,
                turret_angles: value.turret_angles.iter().map(|value| value).collect(),
            }
        }
    }

    impl<'raw> ::bebop::SubRecord<'raw> for Contact {
        const MIN_SERIALIZED_SIZE: usize = <u8>::MIN_SERIALIZED_SIZE
            + <u32>::MIN_SERIALIZED_SIZE
            + <EntityType>::MIN_SERIALIZED_SIZE
            + <Guidance>::MIN_SERIALIZED_SIZE
            + <u32>::MIN_SERIALIZED_SIZE
            + <::std::vec::Vec<bool>>::MIN_SERIALIZED_SIZE
            + <Transform>::MIN_SERIALIZED_SIZE
            + <::std::vec::Vec<u32>>::MIN_SERIALIZED_SIZE;

        #[inline]
        fn serialized_size(&self) -> usize {
            self.damage.serialized_size()
                + self.entity_id.serialized_size()
                + self.entity_type.serialized_size()
                + self.guidance.serialized_size()
                + self.player_id.serialized_size()
                + self.reloads.serialized_size()
                + self.transform.serialized_size()
                + self.turret_angles.serialized_size()
        }

        ::bebop::define_serialize_chained!(Self => |zelf, dest| {
            Ok(
                zelf.damage._serialize_chained(dest)? +
                zelf.entity_id._serialize_chained(dest)? +
                zelf.entity_type._serialize_chained(dest)? +
                zelf.guidance._serialize_chained(dest)? +
                zelf.player_id._serialize_chained(dest)? +
                zelf.reloads._serialize_chained(dest)? +
                zelf.transform._serialize_chained(dest)? +
                zelf.turret_angles._serialize_chained(dest)?
            )
        });

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let mut i = 0;
            if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
                let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
                return Err(::bebop::DeserializeError::MoreDataExpected(missing));
            }

            let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v2) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v3) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v4) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v5) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v6) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v7) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;

            Ok((
                i,
                Self {
                    damage: v0,
                    entity_id: v1,
                    entity_type: v2,
                    guidance: v3,
                    player_id: v4,
                    reloads: v5,
                    transform: v6,
                    turret_angles: v7,
                },
            ))
        }
    }

    impl<'raw> ::bebop::Record<'raw> for Contact {}

    pub use super::ChunkId;

    #[derive(Clone, Debug, PartialEq)]
    pub struct TerrainUpdate {
        pub chunk_id: ChunkId,
        pub data: ::std::vec::Vec<u8>,
    }

    impl<'raw> ::core::convert::From<super::TerrainUpdate<'raw>> for TerrainUpdate {
        fn from(value: super::TerrainUpdate) -> Self {
            Self {
                chunk_id: value.chunk_id,
                data: value.data.iter().map(|value| value).collect(),
            }
        }
    }

    impl<'raw> ::bebop::SubRecord<'raw> for TerrainUpdate {
        const MIN_SERIALIZED_SIZE: usize =
            <ChunkId>::MIN_SERIALIZED_SIZE + <::std::vec::Vec<u8>>::MIN_SERIALIZED_SIZE;

        #[inline]
        fn serialized_size(&self) -> usize {
            self.chunk_id.serialized_size() + self.data.serialized_size()
        }

        ::bebop::define_serialize_chained!(Self => |zelf, dest| {
            Ok(
                zelf.chunk_id._serialize_chained(dest)? +
                zelf.data._serialize_chained(dest)?
            )
        });

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let mut i = 0;
            if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
                let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
                return Err(::bebop::DeserializeError::MoreDataExpected(missing));
            }

            let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;

            Ok((
                i,
                Self {
                    chunk_id: v0,
                    data: v1,
                },
            ))
        }
    }

    impl<'raw> ::bebop::Record<'raw> for TerrainUpdate {}

    #[derive(Clone, Debug, PartialEq)]
    pub struct Update {
        pub contacts: ::std::vec::Vec<Contact>,
        pub score: u32,
        pub world_radius: f32,
        pub terrain_updates: ::std::vec::Vec<TerrainUpdate>,
    }

    impl<'raw> ::core::convert::From<super::Update<'raw>> for Update {
        fn from(value: super::Update) -> Self {
            Self {
                contacts: value
                    .contacts
                    .into_iter()
                    .map(|value| value.into())
                    .collect(),
                score: value.score,
                world_radius: value.world_radius,
                terrain_updates: value
                    .terrain_updates
                    .into_iter()
                    .map(|value| value.into())
                    .collect(),
            }
        }
    }

    impl<'raw> ::bebop::SubRecord<'raw> for Update {
        const MIN_SERIALIZED_SIZE: usize = <::std::vec::Vec<Contact>>::MIN_SERIALIZED_SIZE
            + <u32>::MIN_SERIALIZED_SIZE
            + <f32>::MIN_SERIALIZED_SIZE
            + <::std::vec::Vec<TerrainUpdate>>::MIN_SERIALIZED_SIZE;

        #[inline]
        fn serialized_size(&self) -> usize {
            self.contacts.serialized_size()
                + self.score.serialized_size()
                + self.world_radius.serialized_size()
                + self.terrain_updates.serialized_size()
        }

        ::bebop::define_serialize_chained!(Self => |zelf, dest| {
            Ok(
                zelf.contacts._serialize_chained(dest)? +
                zelf.score._serialize_chained(dest)? +
                zelf.world_radius._serialize_chained(dest)? +
                zelf.terrain_updates._serialize_chained(dest)?
            )
        });

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let mut i = 0;
            if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
                let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
                return Err(::bebop::DeserializeError::MoreDataExpected(missing));
            }

            let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v2) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v3) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;

            Ok((
                i,
                Self {
                    contacts: v0,
                    score: v1,
                    world_radius: v2,
                    terrain_updates: v3,
                },
            ))
        }
    }

    impl<'raw> ::bebop::Record<'raw> for Update {}

    #[derive(Clone, Debug, PartialEq)]
    pub struct Updates {
        pub updates_: ::std::vec::Vec<Update>,
    }

    impl<'raw> ::core::convert::From<super::Updates<'raw>> for Updates {
        fn from(value: super::Updates) -> Self {
            Self {
                updates_: value
                    .updates_
                    .into_iter()
                    .map(|value| value.into())
                    .collect(),
            }
        }
    }

    impl<'raw> ::bebop::SubRecord<'raw> for Updates {
        const MIN_SERIALIZED_SIZE: usize = <::std::vec::Vec<Update>>::MIN_SERIALIZED_SIZE;

        #[inline]
        fn serialized_size(&self) -> usize {
            self.updates_.serialized_size()
        }

        ::bebop::define_serialize_chained!(Self => |zelf, dest| {
            Ok(
                zelf.updates_._serialize_chained(dest)?
            )
        });

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let mut i = 0;
            if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
                let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
                return Err(::bebop::DeserializeError::MoreDataExpected(missing));
            }

            let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;

            Ok((i, Self { updates_: v0 }))
        }
    }

    impl<'raw> ::bebop::Record<'raw> for Updates {}
}
