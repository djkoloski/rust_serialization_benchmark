// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod mk_48 {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ENTITY_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ENTITY_TYPE: i8 = 9;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ENTITY_TYPE: [EntityType; 10] = [
  EntityType::ArleighBurke,
  EntityType::Bismarck,
  EntityType::Clemenceau,
  EntityType::Fletcher,
  EntityType::G5,
  EntityType::Iowa,
  EntityType::Kolkata,
  EntityType::Osa,
  EntityType::Yasen,
  EntityType::Zubr,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct EntityType(pub i8);
#[allow(non_upper_case_globals)]
impl EntityType {
  pub const ArleighBurke: Self = Self(0);
  pub const Bismarck: Self = Self(1);
  pub const Clemenceau: Self = Self(2);
  pub const Fletcher: Self = Self(3);
  pub const G5: Self = Self(4);
  pub const Iowa: Self = Self(5);
  pub const Kolkata: Self = Self(6);
  pub const Osa: Self = Self(7);
  pub const Yasen: Self = Self(8);
  pub const Zubr: Self = Self(9);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 9;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ArleighBurke,
    Self::Bismarck,
    Self::Clemenceau,
    Self::Fletcher,
    Self::G5,
    Self::Iowa,
    Self::Kolkata,
    Self::Osa,
    Self::Yasen,
    Self::Zubr,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::ArleighBurke => Some("ArleighBurke"),
      Self::Bismarck => Some("Bismarck"),
      Self::Clemenceau => Some("Clemenceau"),
      Self::Fletcher => Some("Fletcher"),
      Self::G5 => Some("G5"),
      Self::Iowa => Some("Iowa"),
      Self::Kolkata => Some("Kolkata"),
      Self::Osa => Some("Osa"),
      Self::Yasen => Some("Yasen"),
      Self::Zubr => Some("Zubr"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for EntityType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for EntityType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for EntityType {
    type Output = EntityType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for EntityType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for EntityType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for EntityType {}
// struct Vector2f, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Vector2f(pub [u8; 8]);
impl Default for Vector2f { 
  fn default() -> Self { 
    Self([0; 8])
  }
}
impl core::fmt::Debug for Vector2f {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Vector2f")
      .field("x", &self.x())
      .field("y", &self.y())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Vector2f {}
impl<'a> flatbuffers::Follow<'a> for Vector2f {
  type Inner = &'a Vector2f;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Vector2f>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Vector2f {
  type Inner = &'a Vector2f;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Vector2f>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Vector2f {
    type Output = Vector2f;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Vector2f as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Vector2f {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Vector2f {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    x: f32,
    y: f32,
  ) -> Self {
    let mut s = Self([0; 8]);
    s.set_x(x);
    s.set_y(y);
    s
  }

  pub fn x(&self) -> f32 {
    let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_x(&mut self, x: f32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn y(&self) -> f32 {
    let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[4..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_y(&mut self, x: f32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[4..].as_mut_ptr(),
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
    }
  }

}

// struct Transform, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Transform(pub [u8; 16]);
impl Default for Transform { 
  fn default() -> Self { 
    Self([0; 16])
  }
}
impl core::fmt::Debug for Transform {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Transform")
      .field("altitude", &self.altitude())
      .field("angle", &self.angle())
      .field("position", &self.position())
      .field("velocity", &self.velocity())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Transform {}
impl<'a> flatbuffers::Follow<'a> for Transform {
  type Inner = &'a Transform;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Transform>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Transform {
  type Inner = &'a Transform;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Transform>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Transform {
    type Output = Transform;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Transform as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Transform {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Transform {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    altitude: i8,
    angle: u16,
    position: &Vector2f,
    velocity: i16,
  ) -> Self {
    let mut s = Self([0; 16]);
    s.set_altitude(altitude);
    s.set_angle(angle);
    s.set_position(position);
    s.set_velocity(velocity);
    s
  }

  pub fn altitude(&self) -> i8 {
    let mut mem = core::mem::MaybeUninit::<<i8 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<i8 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_altitude(&mut self, x: i8) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<i8 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn angle(&self) -> u16 {
    let mut mem = core::mem::MaybeUninit::<<u16 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[2..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u16 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_angle(&mut self, x: u16) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[2..].as_mut_ptr(),
        core::mem::size_of::<<u16 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn position(&self) -> &Vector2f {
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid struct in this slot
    unsafe { &*(self.0[4..].as_ptr() as *const Vector2f) }
  }

  #[allow(clippy::identity_op)]
  pub fn set_position(&mut self, x: &Vector2f) {
    self.0[4..4 + 8].copy_from_slice(&x.0)
  }

  pub fn velocity(&self) -> i16 {
    let mut mem = core::mem::MaybeUninit::<<i16 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[12..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<i16 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_velocity(&mut self, x: i16) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[12..].as_mut_ptr(),
        core::mem::size_of::<<i16 as EndianScalar>::Scalar>(),
      );
    }
  }

}

// struct Guidance, aligned to 2
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Guidance(pub [u8; 6]);
impl Default for Guidance { 
  fn default() -> Self { 
    Self([0; 6])
  }
}
impl core::fmt::Debug for Guidance {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Guidance")
      .field("angle", &self.angle())
      .field("submerge", &self.submerge())
      .field("velocity", &self.velocity())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Guidance {}
impl<'a> flatbuffers::Follow<'a> for Guidance {
  type Inner = &'a Guidance;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Guidance>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Guidance {
  type Inner = &'a Guidance;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Guidance>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Guidance {
    type Output = Guidance;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Guidance as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Guidance {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Guidance {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    angle: u16,
    submerge: bool,
    velocity: i16,
  ) -> Self {
    let mut s = Self([0; 6]);
    s.set_angle(angle);
    s.set_submerge(submerge);
    s.set_velocity(velocity);
    s
  }

  pub fn angle(&self) -> u16 {
    let mut mem = core::mem::MaybeUninit::<<u16 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u16 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_angle(&mut self, x: u16) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<u16 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn submerge(&self) -> bool {
    let mut mem = core::mem::MaybeUninit::<<bool as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[2..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<bool as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_submerge(&mut self, x: bool) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[2..].as_mut_ptr(),
        core::mem::size_of::<<bool as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn velocity(&self) -> i16 {
    let mut mem = core::mem::MaybeUninit::<<i16 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[4..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<i16 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_velocity(&mut self, x: i16) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[4..].as_mut_ptr(),
        core::mem::size_of::<<i16 as EndianScalar>::Scalar>(),
      );
    }
  }

}

// struct ChunkId, aligned to 1
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct ChunkId(pub [u8; 2]);
impl Default for ChunkId { 
  fn default() -> Self { 
    Self([0; 2])
  }
}
impl core::fmt::Debug for ChunkId {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("ChunkId")
      .field("x", &self.x())
      .field("y", &self.y())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ChunkId {}
impl<'a> flatbuffers::Follow<'a> for ChunkId {
  type Inner = &'a ChunkId;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a ChunkId>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a ChunkId {
  type Inner = &'a ChunkId;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<ChunkId>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for ChunkId {
    type Output = ChunkId;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const ChunkId as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for ChunkId {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> ChunkId {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    x: i8,
    y: i8,
  ) -> Self {
    let mut s = Self([0; 2]);
    s.set_x(x);
    s.set_y(y);
    s
  }

  pub fn x(&self) -> i8 {
    let mut mem = core::mem::MaybeUninit::<<i8 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<i8 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_x(&mut self, x: i8) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<i8 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn y(&self) -> i8 {
    let mut mem = core::mem::MaybeUninit::<<i8 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[1..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<i8 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_y(&mut self, x: i8) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[1..].as_mut_ptr(),
        core::mem::size_of::<<i8 as EndianScalar>::Scalar>(),
      );
    }
  }

}

pub enum ContactOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Contact<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Contact<'a> {
  type Inner = Contact<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Contact<'a> {
  pub const VT_DAMAGE: flatbuffers::VOffsetT = 4;
  pub const VT_ENTITY_ID: flatbuffers::VOffsetT = 6;
  pub const VT_ENTITY_TYPE: flatbuffers::VOffsetT = 8;
  pub const VT_GUIDANCE: flatbuffers::VOffsetT = 10;
  pub const VT_PLAYER_ID: flatbuffers::VOffsetT = 12;
  pub const VT_RELOADS: flatbuffers::VOffsetT = 14;
  pub const VT_TRANSFORM: flatbuffers::VOffsetT = 16;
  pub const VT_TURRET_ANGLES: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Contact { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ContactArgs<'args>
  ) -> flatbuffers::WIPOffset<Contact<'bldr>> {
    let mut builder = ContactBuilder::new(_fbb);
    if let Some(x) = args.turret_angles { builder.add_turret_angles(x); }
    if let Some(x) = args.transform { builder.add_transform(x); }
    if let Some(x) = args.reloads { builder.add_reloads(x); }
    if let Some(x) = args.guidance { builder.add_guidance(x); }
    builder.add_entity_id(args.entity_id);
    builder.add_player_id(args.player_id);
    builder.add_entity_type(args.entity_type);
    builder.add_damage(args.damage);
    builder.finish()
  }


  #[inline]
  pub fn damage(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(Contact::VT_DAMAGE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn entity_id(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Contact::VT_ENTITY_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn entity_type(&self) -> EntityType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<EntityType>(Contact::VT_ENTITY_TYPE, Some(EntityType::ArleighBurke)).unwrap()}
  }
  #[inline]
  pub fn guidance(&self) -> Option<&'a Guidance> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Guidance>(Contact::VT_GUIDANCE, None)}
  }
  #[inline]
  pub fn player_id(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(Contact::VT_PLAYER_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn reloads(&self) -> flatbuffers::Vector<'a, bool> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, bool>>>(Contact::VT_RELOADS, None).unwrap()}
  }
  #[inline]
  pub fn transform(&self) -> Option<&'a Transform> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Transform>(Contact::VT_TRANSFORM, None)}
  }
  #[inline]
  pub fn turret_angles(&self) -> flatbuffers::Vector<'a, u16> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(Contact::VT_TURRET_ANGLES, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Contact<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("damage", Self::VT_DAMAGE, false)?
     .visit_field::<u32>("entity_id", Self::VT_ENTITY_ID, false)?
     .visit_field::<EntityType>("entity_type", Self::VT_ENTITY_TYPE, false)?
     .visit_field::<Guidance>("guidance", Self::VT_GUIDANCE, false)?
     .visit_field::<u16>("player_id", Self::VT_PLAYER_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, bool>>>("reloads", Self::VT_RELOADS, true)?
     .visit_field::<Transform>("transform", Self::VT_TRANSFORM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>("turret_angles", Self::VT_TURRET_ANGLES, true)?
     .finish();
    Ok(())
  }
}
pub struct ContactArgs<'a> {
    pub damage: u8,
    pub entity_id: u32,
    pub entity_type: EntityType,
    pub guidance: Option<&'a Guidance>,
    pub player_id: u16,
    pub reloads: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, bool>>>,
    pub transform: Option<&'a Transform>,
    pub turret_angles: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
}
impl<'a> Default for ContactArgs<'a> {
  #[inline]
  fn default() -> Self {
    ContactArgs {
      damage: 0,
      entity_id: 0,
      entity_type: EntityType::ArleighBurke,
      guidance: None,
      player_id: 0,
      reloads: None, // required field
      transform: None,
      turret_angles: None, // required field
    }
  }
}

pub struct ContactBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ContactBuilder<'a, 'b> {
  #[inline]
  pub fn add_damage(&mut self, damage: u8) {
    self.fbb_.push_slot::<u8>(Contact::VT_DAMAGE, damage, 0);
  }
  #[inline]
  pub fn add_entity_id(&mut self, entity_id: u32) {
    self.fbb_.push_slot::<u32>(Contact::VT_ENTITY_ID, entity_id, 0);
  }
  #[inline]
  pub fn add_entity_type(&mut self, entity_type: EntityType) {
    self.fbb_.push_slot::<EntityType>(Contact::VT_ENTITY_TYPE, entity_type, EntityType::ArleighBurke);
  }
  #[inline]
  pub fn add_guidance(&mut self, guidance: &Guidance) {
    self.fbb_.push_slot_always::<&Guidance>(Contact::VT_GUIDANCE, guidance);
  }
  #[inline]
  pub fn add_player_id(&mut self, player_id: u16) {
    self.fbb_.push_slot::<u16>(Contact::VT_PLAYER_ID, player_id, 0);
  }
  #[inline]
  pub fn add_reloads(&mut self, reloads: flatbuffers::WIPOffset<flatbuffers::Vector<'b , bool>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Contact::VT_RELOADS, reloads);
  }
  #[inline]
  pub fn add_transform(&mut self, transform: &Transform) {
    self.fbb_.push_slot_always::<&Transform>(Contact::VT_TRANSFORM, transform);
  }
  #[inline]
  pub fn add_turret_angles(&mut self, turret_angles: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Contact::VT_TURRET_ANGLES, turret_angles);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ContactBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ContactBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Contact<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Contact::VT_RELOADS,"reloads");
    self.fbb_.required(o, Contact::VT_TURRET_ANGLES,"turret_angles");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Contact<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Contact");
      ds.field("damage", &self.damage());
      ds.field("entity_id", &self.entity_id());
      ds.field("entity_type", &self.entity_type());
      ds.field("guidance", &self.guidance());
      ds.field("player_id", &self.player_id());
      ds.field("reloads", &self.reloads());
      ds.field("transform", &self.transform());
      ds.field("turret_angles", &self.turret_angles());
      ds.finish()
  }
}
pub enum TerrainUpdateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TerrainUpdate<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TerrainUpdate<'a> {
  type Inner = TerrainUpdate<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TerrainUpdate<'a> {
  pub const VT_CHUNK_ID: flatbuffers::VOffsetT = 4;
  pub const VT_DATA: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TerrainUpdate { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args TerrainUpdateArgs<'args>
  ) -> flatbuffers::WIPOffset<TerrainUpdate<'bldr>> {
    let mut builder = TerrainUpdateBuilder::new(_fbb);
    if let Some(x) = args.data { builder.add_data(x); }
    if let Some(x) = args.chunk_id { builder.add_chunk_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn chunk_id(&self) -> Option<&'a ChunkId> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ChunkId>(TerrainUpdate::VT_CHUNK_ID, None)}
  }
  #[inline]
  pub fn data(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(TerrainUpdate::VT_DATA, None)}
  }
}

impl flatbuffers::Verifiable for TerrainUpdate<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<ChunkId>("chunk_id", Self::VT_CHUNK_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("data", Self::VT_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct TerrainUpdateArgs<'a> {
    pub chunk_id: Option<&'a ChunkId>,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for TerrainUpdateArgs<'a> {
  #[inline]
  fn default() -> Self {
    TerrainUpdateArgs {
      chunk_id: None,
      data: None,
    }
  }
}

pub struct TerrainUpdateBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TerrainUpdateBuilder<'a, 'b> {
  #[inline]
  pub fn add_chunk_id(&mut self, chunk_id: &ChunkId) {
    self.fbb_.push_slot_always::<&ChunkId>(TerrainUpdate::VT_CHUNK_ID, chunk_id);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TerrainUpdate::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TerrainUpdateBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TerrainUpdateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TerrainUpdate<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TerrainUpdate<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TerrainUpdate");
      ds.field("chunk_id", &self.chunk_id());
      ds.field("data", &self.data());
      ds.finish()
  }
}
pub enum UpdateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Update<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Update<'a> {
  type Inner = Update<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Update<'a> {
  pub const VT_CONTACTS: flatbuffers::VOffsetT = 4;
  pub const VT_SCORE: flatbuffers::VOffsetT = 6;
  pub const VT_WORLD_RADIUS: flatbuffers::VOffsetT = 8;
  pub const VT_TERRAIN_UPDATES: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Update { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args UpdateArgs<'args>
  ) -> flatbuffers::WIPOffset<Update<'bldr>> {
    let mut builder = UpdateBuilder::new(_fbb);
    if let Some(x) = args.terrain_updates { builder.add_terrain_updates(x); }
    builder.add_world_radius(args.world_radius);
    builder.add_score(args.score);
    if let Some(x) = args.contacts { builder.add_contacts(x); }
    builder.finish()
  }


  #[inline]
  pub fn contacts(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Contact<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Contact>>>>(Update::VT_CONTACTS, None).unwrap()}
  }
  #[inline]
  pub fn score(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Update::VT_SCORE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn world_radius(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Update::VT_WORLD_RADIUS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn terrain_updates(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TerrainUpdate<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TerrainUpdate>>>>(Update::VT_TERRAIN_UPDATES, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Update<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Contact>>>>("contacts", Self::VT_CONTACTS, true)?
     .visit_field::<u32>("score", Self::VT_SCORE, false)?
     .visit_field::<f32>("world_radius", Self::VT_WORLD_RADIUS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TerrainUpdate>>>>("terrain_updates", Self::VT_TERRAIN_UPDATES, true)?
     .finish();
    Ok(())
  }
}
pub struct UpdateArgs<'a> {
    pub contacts: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Contact<'a>>>>>,
    pub score: u32,
    pub world_radius: f32,
    pub terrain_updates: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TerrainUpdate<'a>>>>>,
}
impl<'a> Default for UpdateArgs<'a> {
  #[inline]
  fn default() -> Self {
    UpdateArgs {
      contacts: None, // required field
      score: 0,
      world_radius: 0.0,
      terrain_updates: None, // required field
    }
  }
}

pub struct UpdateBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UpdateBuilder<'a, 'b> {
  #[inline]
  pub fn add_contacts(&mut self, contacts: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Contact<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Update::VT_CONTACTS, contacts);
  }
  #[inline]
  pub fn add_score(&mut self, score: u32) {
    self.fbb_.push_slot::<u32>(Update::VT_SCORE, score, 0);
  }
  #[inline]
  pub fn add_world_radius(&mut self, world_radius: f32) {
    self.fbb_.push_slot::<f32>(Update::VT_WORLD_RADIUS, world_radius, 0.0);
  }
  #[inline]
  pub fn add_terrain_updates(&mut self, terrain_updates: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<TerrainUpdate<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Update::VT_TERRAIN_UPDATES, terrain_updates);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UpdateBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UpdateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Update<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Update::VT_CONTACTS,"contacts");
    self.fbb_.required(o, Update::VT_TERRAIN_UPDATES,"terrain_updates");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Update<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Update");
      ds.field("contacts", &self.contacts());
      ds.field("score", &self.score());
      ds.field("world_radius", &self.world_radius());
      ds.field("terrain_updates", &self.terrain_updates());
      ds.finish()
  }
}
pub enum UpdatesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Updates<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Updates<'a> {
  type Inner = Updates<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Updates<'a> {
  pub const VT_UPDATES: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Updates { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args UpdatesArgs<'args>
  ) -> flatbuffers::WIPOffset<Updates<'bldr>> {
    let mut builder = UpdatesBuilder::new(_fbb);
    if let Some(x) = args.updates { builder.add_updates(x); }
    builder.finish()
  }


  #[inline]
  pub fn updates(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Update<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Update>>>>(Updates::VT_UPDATES, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Updates<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Update>>>>("updates", Self::VT_UPDATES, true)?
     .finish();
    Ok(())
  }
}
pub struct UpdatesArgs<'a> {
    pub updates: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Update<'a>>>>>,
}
impl<'a> Default for UpdatesArgs<'a> {
  #[inline]
  fn default() -> Self {
    UpdatesArgs {
      updates: None, // required field
    }
  }
}

pub struct UpdatesBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UpdatesBuilder<'a, 'b> {
  #[inline]
  pub fn add_updates(&mut self, updates: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Update<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Updates::VT_UPDATES, updates);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UpdatesBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UpdatesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Updates<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Updates::VT_UPDATES,"updates");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Updates<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Updates");
      ds.field("updates", &self.updates());
      ds.finish()
  }
}
}  // pub mod mk48

