// automatically generated by the FlatBuffers compiler, do not modify

use std::cmp::Ordering;
use std::mem;

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

#[allow(unused_imports, dead_code)]
pub mod minecraft_savedata {

    use std::cmp::Ordering;
    use std::mem;

    extern crate flatbuffers;
    use self::flatbuffers::EndianScalar;

    #[allow(non_camel_case_types)]
    #[repr(i8)]
    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
    pub enum GameType {
        Survival = 0,
        Creative = 1,
        Adventure = 2,
        Spectator = 3,
    }

    pub const ENUM_MIN_GAME_TYPE: i8 = 0;
    pub const ENUM_MAX_GAME_TYPE: i8 = 3;

    impl<'a> flatbuffers::Follow<'a> for GameType {
        type Inner = Self;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::read_scalar_at::<Self>(buf, loc)
        }
    }

    impl flatbuffers::EndianScalar for GameType {
        #[inline]
        fn to_little_endian(self) -> Self {
            let n = i8::to_le(self as i8);
            let p = &n as *const i8 as *const GameType;
            unsafe { *p }
        }
        #[inline]
        fn from_little_endian(self) -> Self {
            let n = i8::from_le(self as i8);
            let p = &n as *const i8 as *const GameType;
            unsafe { *p }
        }
    }

    impl flatbuffers::Push for GameType {
        type Output = GameType;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            flatbuffers::emplace_scalar::<GameType>(dst, *self);
        }
    }

    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_GAME_TYPE: [GameType; 4] = [
        GameType::Survival,
        GameType::Creative,
        GameType::Adventure,
        GameType::Spectator,
    ];

    #[allow(non_camel_case_types)]
    pub const ENUM_NAMES_GAME_TYPE: [&'static str; 4] =
        ["Survival", "Creative", "Adventure", "Spectator"];

    pub fn enum_name_game_type(e: GameType) -> &'static str {
        let index = e as i8;
        ENUM_NAMES_GAME_TYPE[index as usize]
    }

    // struct Abilities, aligned to 4
    #[repr(C, align(4))]
    #[derive(Clone, Copy, Debug, PartialEq)]
    pub struct Abilities {
        walk_speed_: f32,
        fly_speed_: f32,
        may_fly_: bool,
        flying_: bool,
        invulnerable_: bool,
        may_build_: bool,
        instabuild_: bool,
        padding0__: u8,
        padding1__: u16,
    } // pub struct Abilities
    impl flatbuffers::SafeSliceAccess for Abilities {}
    impl<'a> flatbuffers::Follow<'a> for Abilities {
        type Inner = &'a Abilities;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a Abilities>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a Abilities {
        type Inner = &'a Abilities;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<Abilities>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for Abilities {
        type Output = Abilities;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            let src = unsafe {
                ::std::slice::from_raw_parts(self as *const Abilities as *const u8, Self::size())
            };
            dst.copy_from_slice(src);
        }
    }
    impl<'b> flatbuffers::Push for &'b Abilities {
        type Output = Abilities;

        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            let src = unsafe {
                ::std::slice::from_raw_parts(*self as *const Abilities as *const u8, Self::size())
            };
            dst.copy_from_slice(src);
        }
    }

    impl Abilities {
        pub fn new<'a>(
            _walk_speed: f32,
            _fly_speed: f32,
            _may_fly: bool,
            _flying: bool,
            _invulnerable: bool,
            _may_build: bool,
            _instabuild: bool,
        ) -> Self {
            Abilities {
                walk_speed_: _walk_speed.to_little_endian(),
                fly_speed_: _fly_speed.to_little_endian(),
                may_fly_: _may_fly.to_little_endian(),
                flying_: _flying.to_little_endian(),
                invulnerable_: _invulnerable.to_little_endian(),
                may_build_: _may_build.to_little_endian(),
                instabuild_: _instabuild.to_little_endian(),

                padding0__: 0,
                padding1__: 0,
            }
        }
        pub fn walk_speed<'a>(&'a self) -> f32 {
            self.walk_speed_.from_little_endian()
        }
        pub fn fly_speed<'a>(&'a self) -> f32 {
            self.fly_speed_.from_little_endian()
        }
        pub fn may_fly<'a>(&'a self) -> bool {
            self.may_fly_.from_little_endian()
        }
        pub fn flying<'a>(&'a self) -> bool {
            self.flying_.from_little_endian()
        }
        pub fn invulnerable<'a>(&'a self) -> bool {
            self.invulnerable_.from_little_endian()
        }
        pub fn may_build<'a>(&'a self) -> bool {
            self.may_build_.from_little_endian()
        }
        pub fn instabuild<'a>(&'a self) -> bool {
            self.instabuild_.from_little_endian()
        }
    }

    // struct Vector2f, aligned to 4
    #[repr(C, align(4))]
    #[derive(Clone, Copy, Debug, PartialEq)]
    pub struct Vector2f {
        x_: f32,
        y_: f32,
    } // pub struct Vector2f
    impl flatbuffers::SafeSliceAccess for Vector2f {}
    impl<'a> flatbuffers::Follow<'a> for Vector2f {
        type Inner = &'a Vector2f;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a Vector2f>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a Vector2f {
        type Inner = &'a Vector2f;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<Vector2f>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for Vector2f {
        type Output = Vector2f;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            let src = unsafe {
                ::std::slice::from_raw_parts(self as *const Vector2f as *const u8, Self::size())
            };
            dst.copy_from_slice(src);
        }
    }
    impl<'b> flatbuffers::Push for &'b Vector2f {
        type Output = Vector2f;

        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            let src = unsafe {
                ::std::slice::from_raw_parts(*self as *const Vector2f as *const u8, Self::size())
            };
            dst.copy_from_slice(src);
        }
    }

    impl Vector2f {
        pub fn new<'a>(_x: f32, _y: f32) -> Self {
            Vector2f {
                x_: _x.to_little_endian(),
                y_: _y.to_little_endian(),
            }
        }
        pub fn x<'a>(&'a self) -> f32 {
            self.x_.from_little_endian()
        }
        pub fn y<'a>(&'a self) -> f32 {
            self.y_.from_little_endian()
        }
    }

    // struct Vector3d, aligned to 8
    #[repr(C, align(8))]
    #[derive(Clone, Copy, Debug, PartialEq)]
    pub struct Vector3d {
        x_: f64,
        y_: f64,
        z_: f64,
    } // pub struct Vector3d
    impl flatbuffers::SafeSliceAccess for Vector3d {}
    impl<'a> flatbuffers::Follow<'a> for Vector3d {
        type Inner = &'a Vector3d;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a Vector3d>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a Vector3d {
        type Inner = &'a Vector3d;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<Vector3d>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for Vector3d {
        type Output = Vector3d;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            let src = unsafe {
                ::std::slice::from_raw_parts(self as *const Vector3d as *const u8, Self::size())
            };
            dst.copy_from_slice(src);
        }
    }
    impl<'b> flatbuffers::Push for &'b Vector3d {
        type Output = Vector3d;

        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            let src = unsafe {
                ::std::slice::from_raw_parts(*self as *const Vector3d as *const u8, Self::size())
            };
            dst.copy_from_slice(src);
        }
    }

    impl Vector3d {
        pub fn new<'a>(_x: f64, _y: f64, _z: f64) -> Self {
            Vector3d {
                x_: _x.to_little_endian(),
                y_: _y.to_little_endian(),
                z_: _z.to_little_endian(),
            }
        }
        pub fn x<'a>(&'a self) -> f64 {
            self.x_.from_little_endian()
        }
        pub fn y<'a>(&'a self) -> f64 {
            self.y_.from_little_endian()
        }
        pub fn z<'a>(&'a self) -> f64 {
            self.z_.from_little_endian()
        }
    }

    // struct Uuid, aligned to 4
    #[repr(C, align(4))]
    #[derive(Clone, Copy, Debug, PartialEq)]
    pub struct Uuid {
        x0_: u32,
        x1_: u32,
        x2_: u32,
        x3_: u32,
    } // pub struct Uuid
    impl flatbuffers::SafeSliceAccess for Uuid {}
    impl<'a> flatbuffers::Follow<'a> for Uuid {
        type Inner = &'a Uuid;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a Uuid>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a Uuid {
        type Inner = &'a Uuid;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<Uuid>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for Uuid {
        type Output = Uuid;
        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            let src = unsafe {
                ::std::slice::from_raw_parts(self as *const Uuid as *const u8, Self::size())
            };
            dst.copy_from_slice(src);
        }
    }
    impl<'b> flatbuffers::Push for &'b Uuid {
        type Output = Uuid;

        #[inline]
        fn push(&self, dst: &mut [u8], _rest: &[u8]) {
            let src = unsafe {
                ::std::slice::from_raw_parts(*self as *const Uuid as *const u8, Self::size())
            };
            dst.copy_from_slice(src);
        }
    }

    impl Uuid {
        pub fn new<'a>(_x0: u32, _x1: u32, _x2: u32, _x3: u32) -> Self {
            Uuid {
                x0_: _x0.to_little_endian(),
                x1_: _x1.to_little_endian(),
                x2_: _x2.to_little_endian(),
                x3_: _x3.to_little_endian(),
            }
        }
        pub fn x0<'a>(&'a self) -> u32 {
            self.x0_.from_little_endian()
        }
        pub fn x1<'a>(&'a self) -> u32 {
            self.x1_.from_little_endian()
        }
        pub fn x2<'a>(&'a self) -> u32 {
            self.x2_.from_little_endian()
        }
        pub fn x3<'a>(&'a self) -> u32 {
            self.x3_.from_little_endian()
        }
    }

    pub enum ItemOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct Item<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Item<'a> {
        type Inner = Item<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> Item<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Item { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args ItemArgs<'args>,
        ) -> flatbuffers::WIPOffset<Item<'bldr>> {
            let mut builder = ItemBuilder::new(_fbb);
            if let Some(x) = args.id {
                builder.add_id(x);
            }
            builder.add_slot(args.slot);
            builder.add_count(args.count);
            builder.finish()
        }

        pub const VT_COUNT: flatbuffers::VOffsetT = 4;
        pub const VT_SLOT: flatbuffers::VOffsetT = 6;
        pub const VT_ID: flatbuffers::VOffsetT = 8;

        #[inline]
        pub fn count(&self) -> i8 {
            self._tab.get::<i8>(Item::VT_COUNT, Some(0)).unwrap()
        }
        #[inline]
        pub fn slot(&self) -> u8 {
            self._tab.get::<u8>(Item::VT_SLOT, Some(0)).unwrap()
        }
        #[inline]
        pub fn id(&self) -> &'a str {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Item::VT_ID, None)
                .unwrap()
        }
    }

    pub struct ItemArgs<'a> {
        pub count: i8,
        pub slot: u8,
        pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    }
    impl<'a> Default for ItemArgs<'a> {
        #[inline]
        fn default() -> Self {
            ItemArgs {
                count: 0,
                slot: 0,
                id: None, // required field
            }
        }
    }
    pub struct ItemBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> ItemBuilder<'a, 'b> {
        #[inline]
        pub fn add_count(&mut self, count: i8) {
            self.fbb_.push_slot::<i8>(Item::VT_COUNT, count, 0);
        }
        #[inline]
        pub fn add_slot(&mut self, slot: u8) {
            self.fbb_.push_slot::<u8>(Item::VT_SLOT, slot, 0);
        }
        #[inline]
        pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Item::VT_ID, id);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ItemBuilder<'a, 'b> {
            let start = _fbb.start_table();
            ItemBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Item<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, Item::VT_ID, "id");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum EntityOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct Entity<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Entity<'a> {
        type Inner = Entity<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> Entity<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Entity { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args EntityArgs<'args>,
        ) -> flatbuffers::WIPOffset<Entity<'bldr>> {
            let mut builder = EntityBuilder::new(_fbb);
            if let Some(x) = args.custom_name {
                builder.add_custom_name(x);
            }
            if let Some(x) = args.uuid {
                builder.add_uuid(x);
            }
            builder.add_portal_cooldown(args.portal_cooldown);
            builder.add_fall_distance(args.fall_distance);
            if let Some(x) = args.rotation {
                builder.add_rotation(x);
            }
            if let Some(x) = args.motion {
                builder.add_motion(x);
            }
            if let Some(x) = args.pos {
                builder.add_pos(x);
            }
            if let Some(x) = args.id {
                builder.add_id(x);
            }
            builder.add_air(args.air);
            builder.add_fire(args.fire);
            builder.add_glowing(args.glowing);
            builder.add_silent(args.silent);
            builder.add_custom_name_visible(args.custom_name_visible);
            builder.add_invulnerable(args.invulnerable);
            builder.add_no_gravity(args.no_gravity);
            builder.add_on_ground(args.on_ground);
            builder.finish()
        }

        pub const VT_ID: flatbuffers::VOffsetT = 4;
        pub const VT_POS: flatbuffers::VOffsetT = 6;
        pub const VT_MOTION: flatbuffers::VOffsetT = 8;
        pub const VT_ROTATION: flatbuffers::VOffsetT = 10;
        pub const VT_FALL_DISTANCE: flatbuffers::VOffsetT = 12;
        pub const VT_FIRE: flatbuffers::VOffsetT = 14;
        pub const VT_AIR: flatbuffers::VOffsetT = 16;
        pub const VT_ON_GROUND: flatbuffers::VOffsetT = 18;
        pub const VT_NO_GRAVITY: flatbuffers::VOffsetT = 20;
        pub const VT_INVULNERABLE: flatbuffers::VOffsetT = 22;
        pub const VT_PORTAL_COOLDOWN: flatbuffers::VOffsetT = 24;
        pub const VT_UUID: flatbuffers::VOffsetT = 26;
        pub const VT_CUSTOM_NAME: flatbuffers::VOffsetT = 28;
        pub const VT_CUSTOM_NAME_VISIBLE: flatbuffers::VOffsetT = 30;
        pub const VT_SILENT: flatbuffers::VOffsetT = 32;
        pub const VT_GLOWING: flatbuffers::VOffsetT = 34;

        #[inline]
        pub fn id(&self) -> &'a str {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Entity::VT_ID, None)
                .unwrap()
        }
        #[inline]
        pub fn pos(&self) -> &'a Vector3d {
            self._tab.get::<Vector3d>(Entity::VT_POS, None).unwrap()
        }
        #[inline]
        pub fn motion(&self) -> &'a Vector3d {
            self._tab.get::<Vector3d>(Entity::VT_MOTION, None).unwrap()
        }
        #[inline]
        pub fn rotation(&self) -> &'a Vector2f {
            self._tab
                .get::<Vector2f>(Entity::VT_ROTATION, None)
                .unwrap()
        }
        #[inline]
        pub fn fall_distance(&self) -> f32 {
            self._tab
                .get::<f32>(Entity::VT_FALL_DISTANCE, Some(0.0))
                .unwrap()
        }
        #[inline]
        pub fn fire(&self) -> u16 {
            self._tab.get::<u16>(Entity::VT_FIRE, Some(0)).unwrap()
        }
        #[inline]
        pub fn air(&self) -> u16 {
            self._tab.get::<u16>(Entity::VT_AIR, Some(0)).unwrap()
        }
        #[inline]
        pub fn on_ground(&self) -> bool {
            self._tab
                .get::<bool>(Entity::VT_ON_GROUND, Some(false))
                .unwrap()
        }
        #[inline]
        pub fn no_gravity(&self) -> bool {
            self._tab
                .get::<bool>(Entity::VT_NO_GRAVITY, Some(false))
                .unwrap()
        }
        #[inline]
        pub fn invulnerable(&self) -> bool {
            self._tab
                .get::<bool>(Entity::VT_INVULNERABLE, Some(false))
                .unwrap()
        }
        #[inline]
        pub fn portal_cooldown(&self) -> i32 {
            self._tab
                .get::<i32>(Entity::VT_PORTAL_COOLDOWN, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn uuid(&self) -> &'a Uuid {
            self._tab.get::<Uuid>(Entity::VT_UUID, None).unwrap()
        }
        #[inline]
        pub fn custom_name(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Entity::VT_CUSTOM_NAME, None)
        }
        #[inline]
        pub fn custom_name_visible(&self) -> bool {
            self._tab
                .get::<bool>(Entity::VT_CUSTOM_NAME_VISIBLE, Some(false))
                .unwrap()
        }
        #[inline]
        pub fn silent(&self) -> bool {
            self._tab
                .get::<bool>(Entity::VT_SILENT, Some(false))
                .unwrap()
        }
        #[inline]
        pub fn glowing(&self) -> bool {
            self._tab
                .get::<bool>(Entity::VT_GLOWING, Some(false))
                .unwrap()
        }
    }

    pub struct EntityArgs<'a> {
        pub id: Option<flatbuffers::WIPOffset<&'a str>>,
        pub pos: Option<&'a Vector3d>,
        pub motion: Option<&'a Vector3d>,
        pub rotation: Option<&'a Vector2f>,
        pub fall_distance: f32,
        pub fire: u16,
        pub air: u16,
        pub on_ground: bool,
        pub no_gravity: bool,
        pub invulnerable: bool,
        pub portal_cooldown: i32,
        pub uuid: Option<&'a Uuid>,
        pub custom_name: Option<flatbuffers::WIPOffset<&'a str>>,
        pub custom_name_visible: bool,
        pub silent: bool,
        pub glowing: bool,
    }
    impl<'a> Default for EntityArgs<'a> {
        #[inline]
        fn default() -> Self {
            EntityArgs {
                id: None,       // required field
                pos: None,      // required field
                motion: None,   // required field
                rotation: None, // required field
                fall_distance: 0.0,
                fire: 0,
                air: 0,
                on_ground: false,
                no_gravity: false,
                invulnerable: false,
                portal_cooldown: 0,
                uuid: None, // required field
                custom_name: None,
                custom_name_visible: false,
                silent: false,
                glowing: false,
            }
        }
    }
    pub struct EntityBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> EntityBuilder<'a, 'b> {
        #[inline]
        pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Entity::VT_ID, id);
        }
        #[inline]
        pub fn add_pos(&mut self, pos: &'b Vector3d) {
            self.fbb_.push_slot_always::<&Vector3d>(Entity::VT_POS, pos);
        }
        #[inline]
        pub fn add_motion(&mut self, motion: &'b Vector3d) {
            self.fbb_
                .push_slot_always::<&Vector3d>(Entity::VT_MOTION, motion);
        }
        #[inline]
        pub fn add_rotation(&mut self, rotation: &'b Vector2f) {
            self.fbb_
                .push_slot_always::<&Vector2f>(Entity::VT_ROTATION, rotation);
        }
        #[inline]
        pub fn add_fall_distance(&mut self, fall_distance: f32) {
            self.fbb_
                .push_slot::<f32>(Entity::VT_FALL_DISTANCE, fall_distance, 0.0);
        }
        #[inline]
        pub fn add_fire(&mut self, fire: u16) {
            self.fbb_.push_slot::<u16>(Entity::VT_FIRE, fire, 0);
        }
        #[inline]
        pub fn add_air(&mut self, air: u16) {
            self.fbb_.push_slot::<u16>(Entity::VT_AIR, air, 0);
        }
        #[inline]
        pub fn add_on_ground(&mut self, on_ground: bool) {
            self.fbb_
                .push_slot::<bool>(Entity::VT_ON_GROUND, on_ground, false);
        }
        #[inline]
        pub fn add_no_gravity(&mut self, no_gravity: bool) {
            self.fbb_
                .push_slot::<bool>(Entity::VT_NO_GRAVITY, no_gravity, false);
        }
        #[inline]
        pub fn add_invulnerable(&mut self, invulnerable: bool) {
            self.fbb_
                .push_slot::<bool>(Entity::VT_INVULNERABLE, invulnerable, false);
        }
        #[inline]
        pub fn add_portal_cooldown(&mut self, portal_cooldown: i32) {
            self.fbb_
                .push_slot::<i32>(Entity::VT_PORTAL_COOLDOWN, portal_cooldown, 0);
        }
        #[inline]
        pub fn add_uuid(&mut self, uuid: &'b Uuid) {
            self.fbb_.push_slot_always::<&Uuid>(Entity::VT_UUID, uuid);
        }
        #[inline]
        pub fn add_custom_name(&mut self, custom_name: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Entity::VT_CUSTOM_NAME, custom_name);
        }
        #[inline]
        pub fn add_custom_name_visible(&mut self, custom_name_visible: bool) {
            self.fbb_
                .push_slot::<bool>(Entity::VT_CUSTOM_NAME_VISIBLE, custom_name_visible, false);
        }
        #[inline]
        pub fn add_silent(&mut self, silent: bool) {
            self.fbb_
                .push_slot::<bool>(Entity::VT_SILENT, silent, false);
        }
        #[inline]
        pub fn add_glowing(&mut self, glowing: bool) {
            self.fbb_
                .push_slot::<bool>(Entity::VT_GLOWING, glowing, false);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EntityBuilder<'a, 'b> {
            let start = _fbb.start_table();
            EntityBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Entity<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, Entity::VT_ID, "id");
            self.fbb_.required(o, Entity::VT_POS, "pos");
            self.fbb_.required(o, Entity::VT_MOTION, "motion");
            self.fbb_.required(o, Entity::VT_ROTATION, "rotation");
            self.fbb_.required(o, Entity::VT_UUID, "uuid");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum RecipeBookOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct RecipeBook<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for RecipeBook<'a> {
        type Inner = RecipeBook<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> RecipeBook<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            RecipeBook { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args RecipeBookArgs<'args>,
        ) -> flatbuffers::WIPOffset<RecipeBook<'bldr>> {
            let mut builder = RecipeBookBuilder::new(_fbb);
            if let Some(x) = args.to_be_displayed {
                builder.add_to_be_displayed(x);
            }
            if let Some(x) = args.recipes {
                builder.add_recipes(x);
            }
            builder.add_is_smoker_gui_open(args.is_smoker_gui_open);
            builder.add_is_smoker_filtering_craftable(args.is_smoker_filtering_craftable);
            builder.add_is_blasting_furnace_gui_open(args.is_blasting_furnace_gui_open);
            builder.add_is_blasting_furnace_filtering_craftable(
                args.is_blasting_furnace_filtering_craftable,
            );
            builder.add_is_furnace_gui_open(args.is_furnace_gui_open);
            builder.add_is_furnace_filtering_craftable(args.is_furnace_filtering_craftable);
            builder.add_is_gui_open(args.is_gui_open);
            builder.add_is_filtering_craftable(args.is_filtering_craftable);
            builder.finish()
        }

        pub const VT_RECIPES: flatbuffers::VOffsetT = 4;
        pub const VT_TO_BE_DISPLAYED: flatbuffers::VOffsetT = 6;
        pub const VT_IS_FILTERING_CRAFTABLE: flatbuffers::VOffsetT = 8;
        pub const VT_IS_GUI_OPEN: flatbuffers::VOffsetT = 10;
        pub const VT_IS_FURNACE_FILTERING_CRAFTABLE: flatbuffers::VOffsetT = 12;
        pub const VT_IS_FURNACE_GUI_OPEN: flatbuffers::VOffsetT = 14;
        pub const VT_IS_BLASTING_FURNACE_FILTERING_CRAFTABLE: flatbuffers::VOffsetT = 16;
        pub const VT_IS_BLASTING_FURNACE_GUI_OPEN: flatbuffers::VOffsetT = 18;
        pub const VT_IS_SMOKER_FILTERING_CRAFTABLE: flatbuffers::VOffsetT = 20;
        pub const VT_IS_SMOKER_GUI_OPEN: flatbuffers::VOffsetT = 22;

        #[inline]
        pub fn recipes(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>,
                >>(RecipeBook::VT_RECIPES, None)
                .unwrap()
        }
        #[inline]
        pub fn to_be_displayed(
            &self,
        ) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>,
                >>(RecipeBook::VT_TO_BE_DISPLAYED, None)
                .unwrap()
        }
        #[inline]
        pub fn is_filtering_craftable(&self) -> bool {
            self._tab
                .get::<bool>(RecipeBook::VT_IS_FILTERING_CRAFTABLE, Some(false))
                .unwrap()
        }
        #[inline]
        pub fn is_gui_open(&self) -> bool {
            self._tab
                .get::<bool>(RecipeBook::VT_IS_GUI_OPEN, Some(false))
                .unwrap()
        }
        #[inline]
        pub fn is_furnace_filtering_craftable(&self) -> bool {
            self._tab
                .get::<bool>(RecipeBook::VT_IS_FURNACE_FILTERING_CRAFTABLE, Some(false))
                .unwrap()
        }
        #[inline]
        pub fn is_furnace_gui_open(&self) -> bool {
            self._tab
                .get::<bool>(RecipeBook::VT_IS_FURNACE_GUI_OPEN, Some(false))
                .unwrap()
        }
        #[inline]
        pub fn is_blasting_furnace_filtering_craftable(&self) -> bool {
            self._tab
                .get::<bool>(
                    RecipeBook::VT_IS_BLASTING_FURNACE_FILTERING_CRAFTABLE,
                    Some(false),
                )
                .unwrap()
        }
        #[inline]
        pub fn is_blasting_furnace_gui_open(&self) -> bool {
            self._tab
                .get::<bool>(RecipeBook::VT_IS_BLASTING_FURNACE_GUI_OPEN, Some(false))
                .unwrap()
        }
        #[inline]
        pub fn is_smoker_filtering_craftable(&self) -> bool {
            self._tab
                .get::<bool>(RecipeBook::VT_IS_SMOKER_FILTERING_CRAFTABLE, Some(false))
                .unwrap()
        }
        #[inline]
        pub fn is_smoker_gui_open(&self) -> bool {
            self._tab
                .get::<bool>(RecipeBook::VT_IS_SMOKER_GUI_OPEN, Some(false))
                .unwrap()
        }
    }

    pub struct RecipeBookArgs<'a> {
        pub recipes: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
        >,
        pub to_be_displayed: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
        >,
        pub is_filtering_craftable: bool,
        pub is_gui_open: bool,
        pub is_furnace_filtering_craftable: bool,
        pub is_furnace_gui_open: bool,
        pub is_blasting_furnace_filtering_craftable: bool,
        pub is_blasting_furnace_gui_open: bool,
        pub is_smoker_filtering_craftable: bool,
        pub is_smoker_gui_open: bool,
    }
    impl<'a> Default for RecipeBookArgs<'a> {
        #[inline]
        fn default() -> Self {
            RecipeBookArgs {
                recipes: None,         // required field
                to_be_displayed: None, // required field
                is_filtering_craftable: false,
                is_gui_open: false,
                is_furnace_filtering_craftable: false,
                is_furnace_gui_open: false,
                is_blasting_furnace_filtering_craftable: false,
                is_blasting_furnace_gui_open: false,
                is_smoker_filtering_craftable: false,
                is_smoker_gui_open: false,
            }
        }
    }
    pub struct RecipeBookBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> RecipeBookBuilder<'a, 'b> {
        #[inline]
        pub fn add_recipes(
            &mut self,
            recipes: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(RecipeBook::VT_RECIPES, recipes);
        }
        #[inline]
        pub fn add_to_be_displayed(
            &mut self,
            to_be_displayed: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
            >,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                RecipeBook::VT_TO_BE_DISPLAYED,
                to_be_displayed,
            );
        }
        #[inline]
        pub fn add_is_filtering_craftable(&mut self, is_filtering_craftable: bool) {
            self.fbb_.push_slot::<bool>(
                RecipeBook::VT_IS_FILTERING_CRAFTABLE,
                is_filtering_craftable,
                false,
            );
        }
        #[inline]
        pub fn add_is_gui_open(&mut self, is_gui_open: bool) {
            self.fbb_
                .push_slot::<bool>(RecipeBook::VT_IS_GUI_OPEN, is_gui_open, false);
        }
        #[inline]
        pub fn add_is_furnace_filtering_craftable(&mut self, is_furnace_filtering_craftable: bool) {
            self.fbb_.push_slot::<bool>(
                RecipeBook::VT_IS_FURNACE_FILTERING_CRAFTABLE,
                is_furnace_filtering_craftable,
                false,
            );
        }
        #[inline]
        pub fn add_is_furnace_gui_open(&mut self, is_furnace_gui_open: bool) {
            self.fbb_.push_slot::<bool>(
                RecipeBook::VT_IS_FURNACE_GUI_OPEN,
                is_furnace_gui_open,
                false,
            );
        }
        #[inline]
        pub fn add_is_blasting_furnace_filtering_craftable(
            &mut self,
            is_blasting_furnace_filtering_craftable: bool,
        ) {
            self.fbb_.push_slot::<bool>(
                RecipeBook::VT_IS_BLASTING_FURNACE_FILTERING_CRAFTABLE,
                is_blasting_furnace_filtering_craftable,
                false,
            );
        }
        #[inline]
        pub fn add_is_blasting_furnace_gui_open(&mut self, is_blasting_furnace_gui_open: bool) {
            self.fbb_.push_slot::<bool>(
                RecipeBook::VT_IS_BLASTING_FURNACE_GUI_OPEN,
                is_blasting_furnace_gui_open,
                false,
            );
        }
        #[inline]
        pub fn add_is_smoker_filtering_craftable(&mut self, is_smoker_filtering_craftable: bool) {
            self.fbb_.push_slot::<bool>(
                RecipeBook::VT_IS_SMOKER_FILTERING_CRAFTABLE,
                is_smoker_filtering_craftable,
                false,
            );
        }
        #[inline]
        pub fn add_is_smoker_gui_open(&mut self, is_smoker_gui_open: bool) {
            self.fbb_.push_slot::<bool>(
                RecipeBook::VT_IS_SMOKER_GUI_OPEN,
                is_smoker_gui_open,
                false,
            );
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RecipeBookBuilder<'a, 'b> {
            let start = _fbb.start_table();
            RecipeBookBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<RecipeBook<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, RecipeBook::VT_RECIPES, "recipes");
            self.fbb_
                .required(o, RecipeBook::VT_TO_BE_DISPLAYED, "to_be_displayed");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum VehicleOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct Vehicle<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Vehicle<'a> {
        type Inner = Vehicle<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> Vehicle<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Vehicle { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args VehicleArgs<'args>,
        ) -> flatbuffers::WIPOffset<Vehicle<'bldr>> {
            let mut builder = VehicleBuilder::new(_fbb);
            if let Some(x) = args.entity {
                builder.add_entity(x);
            }
            builder.add_param_3(args.param_3);
            builder.add_param_2(args.param_2);
            builder.add_param_1(args.param_1);
            builder.add_param_0(args.param_0);
            builder.finish()
        }

        pub const VT_PARAM_0: flatbuffers::VOffsetT = 4;
        pub const VT_PARAM_1: flatbuffers::VOffsetT = 6;
        pub const VT_PARAM_2: flatbuffers::VOffsetT = 8;
        pub const VT_PARAM_3: flatbuffers::VOffsetT = 10;
        pub const VT_ENTITY: flatbuffers::VOffsetT = 12;

        #[inline]
        pub fn param_0(&self) -> u32 {
            self._tab.get::<u32>(Vehicle::VT_PARAM_0, Some(0)).unwrap()
        }
        #[inline]
        pub fn param_1(&self) -> u32 {
            self._tab.get::<u32>(Vehicle::VT_PARAM_1, Some(0)).unwrap()
        }
        #[inline]
        pub fn param_2(&self) -> u32 {
            self._tab.get::<u32>(Vehicle::VT_PARAM_2, Some(0)).unwrap()
        }
        #[inline]
        pub fn param_3(&self) -> u32 {
            self._tab.get::<u32>(Vehicle::VT_PARAM_3, Some(0)).unwrap()
        }
        #[inline]
        pub fn entity(&self) -> Entity<'a> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Entity<'a>>>(Vehicle::VT_ENTITY, None)
                .unwrap()
        }
    }

    pub struct VehicleArgs<'a> {
        pub param_0: u32,
        pub param_1: u32,
        pub param_2: u32,
        pub param_3: u32,
        pub entity: Option<flatbuffers::WIPOffset<Entity<'a>>>,
    }
    impl<'a> Default for VehicleArgs<'a> {
        #[inline]
        fn default() -> Self {
            VehicleArgs {
                param_0: 0,
                param_1: 0,
                param_2: 0,
                param_3: 0,
                entity: None, // required field
            }
        }
    }
    pub struct VehicleBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> VehicleBuilder<'a, 'b> {
        #[inline]
        pub fn add_param_0(&mut self, param_0: u32) {
            self.fbb_.push_slot::<u32>(Vehicle::VT_PARAM_0, param_0, 0);
        }
        #[inline]
        pub fn add_param_1(&mut self, param_1: u32) {
            self.fbb_.push_slot::<u32>(Vehicle::VT_PARAM_1, param_1, 0);
        }
        #[inline]
        pub fn add_param_2(&mut self, param_2: u32) {
            self.fbb_.push_slot::<u32>(Vehicle::VT_PARAM_2, param_2, 0);
        }
        #[inline]
        pub fn add_param_3(&mut self, param_3: u32) {
            self.fbb_.push_slot::<u32>(Vehicle::VT_PARAM_3, param_3, 0);
        }
        #[inline]
        pub fn add_entity(&mut self, entity: flatbuffers::WIPOffset<Entity<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Entity>>(Vehicle::VT_ENTITY, entity);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> VehicleBuilder<'a, 'b> {
            let start = _fbb.start_table();
            VehicleBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Vehicle<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, Vehicle::VT_ENTITY, "entity");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum PlayerOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct Player<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Player<'a> {
        type Inner = Player<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> Player<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Player { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PlayerArgs<'args>,
        ) -> flatbuffers::WIPOffset<Player<'bldr>> {
            let mut builder = PlayerBuilder::new(_fbb);
            builder.add_spawn_z(args.spawn_z);
            builder.add_spawn_y(args.spawn_y);
            builder.add_spawn_x(args.spawn_x);
            builder.add_score(args.score);
            if let Some(x) = args.recipe_book {
                builder.add_recipe_book(x);
            }
            if let Some(x) = args.shoulder_entity_right {
                builder.add_shoulder_entity_right(x);
            }
            if let Some(x) = args.shoulder_entity_left {
                builder.add_shoulder_entity_left(x);
            }
            if let Some(x) = args.root_vehicle {
                builder.add_root_vehicle(x);
            }
            if let Some(x) = args.entered_nether_position {
                builder.add_entered_nether_position(x);
            }
            if let Some(x) = args.abilities {
                builder.add_abilities(x);
            }
            if let Some(x) = args.ender_items {
                builder.add_ender_items(x);
            }
            if let Some(x) = args.inventory {
                builder.add_inventory(x);
            }
            builder.add_xp_seed(args.xp_seed);
            builder.add_xp_total(args.xp_total);
            builder.add_xp_p(args.xp_p);
            builder.add_xp_level(args.xp_level);
            builder.add_food_tick_timer(args.food_tick_timer);
            builder.add_food_saturation_level(args.food_saturation_level);
            builder.add_food_exhaustion_level(args.food_exhaustion_level);
            if let Some(x) = args.spawn_dimension {
                builder.add_spawn_dimension(x);
            }
            if let Some(x) = args.selected_item {
                builder.add_selected_item(x);
            }
            builder.add_selected_item_slot(args.selected_item_slot);
            if let Some(x) = args.dimension {
                builder.add_dimension(x);
            }
            builder.add_sleep_timer(args.sleep_timer);
            builder.add_seen_credits(args.seen_credits);
            builder.add_spawn_forced(args.spawn_forced);
            builder.add_previous_game_type(args.previous_game_type);
            builder.add_game_type(args.game_type);
            builder.finish()
        }

        pub const VT_GAME_TYPE: flatbuffers::VOffsetT = 4;
        pub const VT_PREVIOUS_GAME_TYPE: flatbuffers::VOffsetT = 6;
        pub const VT_SCORE: flatbuffers::VOffsetT = 8;
        pub const VT_DIMENSION: flatbuffers::VOffsetT = 10;
        pub const VT_SELECTED_ITEM_SLOT: flatbuffers::VOffsetT = 12;
        pub const VT_SELECTED_ITEM: flatbuffers::VOffsetT = 14;
        pub const VT_SPAWN_DIMENSION: flatbuffers::VOffsetT = 16;
        pub const VT_SPAWN_X: flatbuffers::VOffsetT = 18;
        pub const VT_SPAWN_Y: flatbuffers::VOffsetT = 20;
        pub const VT_SPAWN_Z: flatbuffers::VOffsetT = 22;
        pub const VT_SPAWN_FORCED: flatbuffers::VOffsetT = 24;
        pub const VT_SLEEP_TIMER: flatbuffers::VOffsetT = 26;
        pub const VT_FOOD_EXHAUSTION_LEVEL: flatbuffers::VOffsetT = 28;
        pub const VT_FOOD_SATURATION_LEVEL: flatbuffers::VOffsetT = 30;
        pub const VT_FOOD_TICK_TIMER: flatbuffers::VOffsetT = 32;
        pub const VT_XP_LEVEL: flatbuffers::VOffsetT = 34;
        pub const VT_XP_P: flatbuffers::VOffsetT = 36;
        pub const VT_XP_TOTAL: flatbuffers::VOffsetT = 38;
        pub const VT_XP_SEED: flatbuffers::VOffsetT = 40;
        pub const VT_INVENTORY: flatbuffers::VOffsetT = 42;
        pub const VT_ENDER_ITEMS: flatbuffers::VOffsetT = 44;
        pub const VT_ABILITIES: flatbuffers::VOffsetT = 46;
        pub const VT_ENTERED_NETHER_POSITION: flatbuffers::VOffsetT = 48;
        pub const VT_ROOT_VEHICLE: flatbuffers::VOffsetT = 50;
        pub const VT_SHOULDER_ENTITY_LEFT: flatbuffers::VOffsetT = 52;
        pub const VT_SHOULDER_ENTITY_RIGHT: flatbuffers::VOffsetT = 54;
        pub const VT_SEEN_CREDITS: flatbuffers::VOffsetT = 56;
        pub const VT_RECIPE_BOOK: flatbuffers::VOffsetT = 58;

        #[inline]
        pub fn game_type(&self) -> GameType {
            self._tab
                .get::<GameType>(Player::VT_GAME_TYPE, Some(GameType::Survival))
                .unwrap()
        }
        #[inline]
        pub fn previous_game_type(&self) -> GameType {
            self._tab
                .get::<GameType>(Player::VT_PREVIOUS_GAME_TYPE, Some(GameType::Survival))
                .unwrap()
        }
        #[inline]
        pub fn score(&self) -> i64 {
            self._tab.get::<i64>(Player::VT_SCORE, Some(0)).unwrap()
        }
        #[inline]
        pub fn dimension(&self) -> &'a str {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Player::VT_DIMENSION, None)
                .unwrap()
        }
        #[inline]
        pub fn selected_item_slot(&self) -> u32 {
            self._tab
                .get::<u32>(Player::VT_SELECTED_ITEM_SLOT, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn selected_item(&self) -> Item<'a> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Item<'a>>>(Player::VT_SELECTED_ITEM, None)
                .unwrap()
        }
        #[inline]
        pub fn spawn_dimension(&self) -> Option<&'a str> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(Player::VT_SPAWN_DIMENSION, None)
        }
        #[inline]
        pub fn spawn_x(&self) -> i64 {
            self._tab.get::<i64>(Player::VT_SPAWN_X, Some(0)).unwrap()
        }
        #[inline]
        pub fn spawn_y(&self) -> i64 {
            self._tab.get::<i64>(Player::VT_SPAWN_Y, Some(0)).unwrap()
        }
        #[inline]
        pub fn spawn_z(&self) -> i64 {
            self._tab.get::<i64>(Player::VT_SPAWN_Z, Some(0)).unwrap()
        }
        #[inline]
        pub fn spawn_forced(&self) -> bool {
            self._tab
                .get::<bool>(Player::VT_SPAWN_FORCED, Some(false))
                .unwrap()
        }
        #[inline]
        pub fn sleep_timer(&self) -> u16 {
            self._tab
                .get::<u16>(Player::VT_SLEEP_TIMER, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn food_exhaustion_level(&self) -> f32 {
            self._tab
                .get::<f32>(Player::VT_FOOD_EXHAUSTION_LEVEL, Some(0.0))
                .unwrap()
        }
        #[inline]
        pub fn food_saturation_level(&self) -> f32 {
            self._tab
                .get::<f32>(Player::VT_FOOD_SATURATION_LEVEL, Some(0.0))
                .unwrap()
        }
        #[inline]
        pub fn food_tick_timer(&self) -> u32 {
            self._tab
                .get::<u32>(Player::VT_FOOD_TICK_TIMER, Some(0))
                .unwrap()
        }
        #[inline]
        pub fn xp_level(&self) -> u32 {
            self._tab.get::<u32>(Player::VT_XP_LEVEL, Some(0)).unwrap()
        }
        #[inline]
        pub fn xp_p(&self) -> f32 {
            self._tab.get::<f32>(Player::VT_XP_P, Some(0.0)).unwrap()
        }
        #[inline]
        pub fn xp_total(&self) -> i32 {
            self._tab.get::<i32>(Player::VT_XP_TOTAL, Some(0)).unwrap()
        }
        #[inline]
        pub fn xp_seed(&self) -> i32 {
            self._tab.get::<i32>(Player::VT_XP_SEED, Some(0)).unwrap()
        }
        #[inline]
        pub fn inventory(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Item<'a>>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<flatbuffers::ForwardsUOffset<Item<'a>>>,
                >>(Player::VT_INVENTORY, None)
                .unwrap()
        }
        #[inline]
        pub fn ender_items(
            &self,
        ) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Item<'a>>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<flatbuffers::ForwardsUOffset<Item<'a>>>,
                >>(Player::VT_ENDER_ITEMS, None)
                .unwrap()
        }
        #[inline]
        pub fn abilities(&self) -> &'a Abilities {
            self._tab
                .get::<Abilities>(Player::VT_ABILITIES, None)
                .unwrap()
        }
        #[inline]
        pub fn entered_nether_position(&self) -> Option<&'a Vector3d> {
            self._tab
                .get::<Vector3d>(Player::VT_ENTERED_NETHER_POSITION, None)
        }
        #[inline]
        pub fn root_vehicle(&self) -> Option<Vehicle<'a>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Vehicle<'a>>>(Player::VT_ROOT_VEHICLE, None)
        }
        #[inline]
        pub fn shoulder_entity_left(&self) -> Option<Entity<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<Entity<'a>>>(
                Player::VT_SHOULDER_ENTITY_LEFT,
                None,
            )
        }
        #[inline]
        pub fn shoulder_entity_right(&self) -> Option<Entity<'a>> {
            self._tab.get::<flatbuffers::ForwardsUOffset<Entity<'a>>>(
                Player::VT_SHOULDER_ENTITY_RIGHT,
                None,
            )
        }
        #[inline]
        pub fn seen_credits(&self) -> bool {
            self._tab
                .get::<bool>(Player::VT_SEEN_CREDITS, Some(false))
                .unwrap()
        }
        #[inline]
        pub fn recipe_book(&self) -> RecipeBook<'a> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<RecipeBook<'a>>>(Player::VT_RECIPE_BOOK, None)
                .unwrap()
        }
    }

    pub struct PlayerArgs<'a> {
        pub game_type: GameType,
        pub previous_game_type: GameType,
        pub score: i64,
        pub dimension: Option<flatbuffers::WIPOffset<&'a str>>,
        pub selected_item_slot: u32,
        pub selected_item: Option<flatbuffers::WIPOffset<Item<'a>>>,
        pub spawn_dimension: Option<flatbuffers::WIPOffset<&'a str>>,
        pub spawn_x: i64,
        pub spawn_y: i64,
        pub spawn_z: i64,
        pub spawn_forced: bool,
        pub sleep_timer: u16,
        pub food_exhaustion_level: f32,
        pub food_saturation_level: f32,
        pub food_tick_timer: u32,
        pub xp_level: u32,
        pub xp_p: f32,
        pub xp_total: i32,
        pub xp_seed: i32,
        pub inventory: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Item<'a>>>>,
        >,
        pub ender_items: Option<
            flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Item<'a>>>>,
        >,
        pub abilities: Option<&'a Abilities>,
        pub entered_nether_position: Option<&'a Vector3d>,
        pub root_vehicle: Option<flatbuffers::WIPOffset<Vehicle<'a>>>,
        pub shoulder_entity_left: Option<flatbuffers::WIPOffset<Entity<'a>>>,
        pub shoulder_entity_right: Option<flatbuffers::WIPOffset<Entity<'a>>>,
        pub seen_credits: bool,
        pub recipe_book: Option<flatbuffers::WIPOffset<RecipeBook<'a>>>,
    }
    impl<'a> Default for PlayerArgs<'a> {
        #[inline]
        fn default() -> Self {
            PlayerArgs {
                game_type: GameType::Survival,
                previous_game_type: GameType::Survival,
                score: 0,
                dimension: None, // required field
                selected_item_slot: 0,
                selected_item: None, // required field
                spawn_dimension: None,
                spawn_x: 0,
                spawn_y: 0,
                spawn_z: 0,
                spawn_forced: false,
                sleep_timer: 0,
                food_exhaustion_level: 0.0,
                food_saturation_level: 0.0,
                food_tick_timer: 0,
                xp_level: 0,
                xp_p: 0.0,
                xp_total: 0,
                xp_seed: 0,
                inventory: None,   // required field
                ender_items: None, // required field
                abilities: None,   // required field
                entered_nether_position: None,
                root_vehicle: None,
                shoulder_entity_left: None,
                shoulder_entity_right: None,
                seen_credits: false,
                recipe_book: None, // required field
            }
        }
    }
    pub struct PlayerBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PlayerBuilder<'a, 'b> {
        #[inline]
        pub fn add_game_type(&mut self, game_type: GameType) {
            self.fbb_
                .push_slot::<GameType>(Player::VT_GAME_TYPE, game_type, GameType::Survival);
        }
        #[inline]
        pub fn add_previous_game_type(&mut self, previous_game_type: GameType) {
            self.fbb_.push_slot::<GameType>(
                Player::VT_PREVIOUS_GAME_TYPE,
                previous_game_type,
                GameType::Survival,
            );
        }
        #[inline]
        pub fn add_score(&mut self, score: i64) {
            self.fbb_.push_slot::<i64>(Player::VT_SCORE, score, 0);
        }
        #[inline]
        pub fn add_dimension(&mut self, dimension: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Player::VT_DIMENSION, dimension);
        }
        #[inline]
        pub fn add_selected_item_slot(&mut self, selected_item_slot: u32) {
            self.fbb_
                .push_slot::<u32>(Player::VT_SELECTED_ITEM_SLOT, selected_item_slot, 0);
        }
        #[inline]
        pub fn add_selected_item(&mut self, selected_item: flatbuffers::WIPOffset<Item<'b>>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Item>>(
                Player::VT_SELECTED_ITEM,
                selected_item,
            );
        }
        #[inline]
        pub fn add_spawn_dimension(&mut self, spawn_dimension: flatbuffers::WIPOffset<&'b str>) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                Player::VT_SPAWN_DIMENSION,
                spawn_dimension,
            );
        }
        #[inline]
        pub fn add_spawn_x(&mut self, spawn_x: i64) {
            self.fbb_.push_slot::<i64>(Player::VT_SPAWN_X, spawn_x, 0);
        }
        #[inline]
        pub fn add_spawn_y(&mut self, spawn_y: i64) {
            self.fbb_.push_slot::<i64>(Player::VT_SPAWN_Y, spawn_y, 0);
        }
        #[inline]
        pub fn add_spawn_z(&mut self, spawn_z: i64) {
            self.fbb_.push_slot::<i64>(Player::VT_SPAWN_Z, spawn_z, 0);
        }
        #[inline]
        pub fn add_spawn_forced(&mut self, spawn_forced: bool) {
            self.fbb_
                .push_slot::<bool>(Player::VT_SPAWN_FORCED, spawn_forced, false);
        }
        #[inline]
        pub fn add_sleep_timer(&mut self, sleep_timer: u16) {
            self.fbb_
                .push_slot::<u16>(Player::VT_SLEEP_TIMER, sleep_timer, 0);
        }
        #[inline]
        pub fn add_food_exhaustion_level(&mut self, food_exhaustion_level: f32) {
            self.fbb_.push_slot::<f32>(
                Player::VT_FOOD_EXHAUSTION_LEVEL,
                food_exhaustion_level,
                0.0,
            );
        }
        #[inline]
        pub fn add_food_saturation_level(&mut self, food_saturation_level: f32) {
            self.fbb_.push_slot::<f32>(
                Player::VT_FOOD_SATURATION_LEVEL,
                food_saturation_level,
                0.0,
            );
        }
        #[inline]
        pub fn add_food_tick_timer(&mut self, food_tick_timer: u32) {
            self.fbb_
                .push_slot::<u32>(Player::VT_FOOD_TICK_TIMER, food_tick_timer, 0);
        }
        #[inline]
        pub fn add_xp_level(&mut self, xp_level: u32) {
            self.fbb_.push_slot::<u32>(Player::VT_XP_LEVEL, xp_level, 0);
        }
        #[inline]
        pub fn add_xp_p(&mut self, xp_p: f32) {
            self.fbb_.push_slot::<f32>(Player::VT_XP_P, xp_p, 0.0);
        }
        #[inline]
        pub fn add_xp_total(&mut self, xp_total: i32) {
            self.fbb_.push_slot::<i32>(Player::VT_XP_TOTAL, xp_total, 0);
        }
        #[inline]
        pub fn add_xp_seed(&mut self, xp_seed: i32) {
            self.fbb_.push_slot::<i32>(Player::VT_XP_SEED, xp_seed, 0);
        }
        #[inline]
        pub fn add_inventory(
            &mut self,
            inventory: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Item<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Player::VT_INVENTORY, inventory);
        }
        #[inline]
        pub fn add_ender_items(
            &mut self,
            ender_items: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Item<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Player::VT_ENDER_ITEMS, ender_items);
        }
        #[inline]
        pub fn add_abilities(&mut self, abilities: &'b Abilities) {
            self.fbb_
                .push_slot_always::<&Abilities>(Player::VT_ABILITIES, abilities);
        }
        #[inline]
        pub fn add_entered_nether_position(&mut self, entered_nether_position: &'b Vector3d) {
            self.fbb_.push_slot_always::<&Vector3d>(
                Player::VT_ENTERED_NETHER_POSITION,
                entered_nether_position,
            );
        }
        #[inline]
        pub fn add_root_vehicle(&mut self, root_vehicle: flatbuffers::WIPOffset<Vehicle<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Vehicle>>(
                    Player::VT_ROOT_VEHICLE,
                    root_vehicle,
                );
        }
        #[inline]
        pub fn add_shoulder_entity_left(
            &mut self,
            shoulder_entity_left: flatbuffers::WIPOffset<Entity<'b>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Entity>>(
                    Player::VT_SHOULDER_ENTITY_LEFT,
                    shoulder_entity_left,
                );
        }
        #[inline]
        pub fn add_shoulder_entity_right(
            &mut self,
            shoulder_entity_right: flatbuffers::WIPOffset<Entity<'b>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Entity>>(
                    Player::VT_SHOULDER_ENTITY_RIGHT,
                    shoulder_entity_right,
                );
        }
        #[inline]
        pub fn add_seen_credits(&mut self, seen_credits: bool) {
            self.fbb_
                .push_slot::<bool>(Player::VT_SEEN_CREDITS, seen_credits, false);
        }
        #[inline]
        pub fn add_recipe_book(&mut self, recipe_book: flatbuffers::WIPOffset<RecipeBook<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<RecipeBook>>(
                    Player::VT_RECIPE_BOOK,
                    recipe_book,
                );
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PlayerBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PlayerBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Player<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, Player::VT_DIMENSION, "dimension");
            self.fbb_
                .required(o, Player::VT_SELECTED_ITEM, "selected_item");
            self.fbb_.required(o, Player::VT_INVENTORY, "inventory");
            self.fbb_.required(o, Player::VT_ENDER_ITEMS, "ender_items");
            self.fbb_.required(o, Player::VT_ABILITIES, "abilities");
            self.fbb_.required(o, Player::VT_RECIPE_BOOK, "recipe_book");
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    pub enum PlayersOffset {}
    #[derive(Copy, Clone, Debug, PartialEq)]

    pub struct Players<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Players<'a> {
        type Inner = Players<'a>;
        #[inline]
        fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table { buf: buf, loc: loc },
            }
        }
    }

    impl<'a> Players<'a> {
        #[inline]
        pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Players { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
            args: &'args PlayersArgs<'args>,
        ) -> flatbuffers::WIPOffset<Players<'bldr>> {
            let mut builder = PlayersBuilder::new(_fbb);
            if let Some(x) = args.players {
                builder.add_players(x);
            }
            builder.finish()
        }

        pub const VT_PLAYERS: flatbuffers::VOffsetT = 4;

        #[inline]
        pub fn players(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Player<'a>>> {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<flatbuffers::ForwardsUOffset<Player<'a>>>,
                >>(Players::VT_PLAYERS, None)
                .unwrap()
        }
    }

    pub struct PlayersArgs<'a> {
        pub players: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Player<'a>>>,
            >,
        >,
    }
    impl<'a> Default for PlayersArgs<'a> {
        #[inline]
        fn default() -> Self {
            PlayersArgs {
                players: None, // required field
            }
        }
    }
    pub struct PlayersBuilder<'a: 'b, 'b> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b> PlayersBuilder<'a, 'b> {
        #[inline]
        pub fn add_players(
            &mut self,
            players: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Player<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Players::VT_PLAYERS, players);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PlayersBuilder<'a, 'b> {
            let start = _fbb.start_table();
            PlayersBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Players<'a>> {
            let o = self.fbb_.end_table(self.start_);
            self.fbb_.required(o, Players::VT_PLAYERS, "players");
            flatbuffers::WIPOffset::new(o.value())
        }
    }
} // pub mod minecraft_savedata
