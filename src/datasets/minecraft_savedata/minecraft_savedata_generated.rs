// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod minecraft_savedata {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_GAME_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_GAME_TYPE: i8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_GAME_TYPE: [GameType; 4] = [
  GameType::Survival,
  GameType::Creative,
  GameType::Adventure,
  GameType::Spectator,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct GameType(pub i8);
#[allow(non_upper_case_globals)]
impl GameType {
  pub const Survival: Self = Self(0);
  pub const Creative: Self = Self(1);
  pub const Adventure: Self = Self(2);
  pub const Spectator: Self = Self(3);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Survival,
    Self::Creative,
    Self::Adventure,
    Self::Spectator,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Survival => Some("Survival"),
      Self::Creative => Some("Creative"),
      Self::Adventure => Some("Adventure"),
      Self::Spectator => Some("Spectator"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for GameType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for GameType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for GameType {
    type Output = GameType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for GameType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for GameType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for GameType {}
// struct Abilities, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Abilities(pub [u8; 16]);
impl Default for Abilities { 
  fn default() -> Self { 
    Self([0; 16])
  }
}
impl core::fmt::Debug for Abilities {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Abilities")
      .field("walk_speed", &self.walk_speed())
      .field("fly_speed", &self.fly_speed())
      .field("may_fly", &self.may_fly())
      .field("flying", &self.flying())
      .field("invulnerable", &self.invulnerable())
      .field("may_build", &self.may_build())
      .field("instabuild", &self.instabuild())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Abilities {}
impl<'a> flatbuffers::Follow<'a> for Abilities {
  type Inner = &'a Abilities;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Abilities>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Abilities {
  type Inner = &'a Abilities;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Abilities>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Abilities {
    type Output = Abilities;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Abilities as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Abilities {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Abilities {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    walk_speed: f32,
    fly_speed: f32,
    may_fly: bool,
    flying: bool,
    invulnerable: bool,
    may_build: bool,
    instabuild: bool,
  ) -> Self {
    let mut s = Self([0; 16]);
    s.set_walk_speed(walk_speed);
    s.set_fly_speed(fly_speed);
    s.set_may_fly(may_fly);
    s.set_flying(flying);
    s.set_invulnerable(invulnerable);
    s.set_may_build(may_build);
    s.set_instabuild(instabuild);
    s
  }

  pub fn walk_speed(&self) -> f32 {
    let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_walk_speed(&mut self, x: f32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn fly_speed(&self) -> f32 {
    let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[4..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_fly_speed(&mut self, x: f32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[4..].as_mut_ptr(),
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn may_fly(&self) -> bool {
    let mut mem = core::mem::MaybeUninit::<<bool as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[8..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<bool as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_may_fly(&mut self, x: bool) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[8..].as_mut_ptr(),
        core::mem::size_of::<<bool as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn flying(&self) -> bool {
    let mut mem = core::mem::MaybeUninit::<<bool as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[9..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<bool as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_flying(&mut self, x: bool) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[9..].as_mut_ptr(),
        core::mem::size_of::<<bool as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn invulnerable(&self) -> bool {
    let mut mem = core::mem::MaybeUninit::<<bool as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[10..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<bool as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_invulnerable(&mut self, x: bool) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[10..].as_mut_ptr(),
        core::mem::size_of::<<bool as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn may_build(&self) -> bool {
    let mut mem = core::mem::MaybeUninit::<<bool as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[11..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<bool as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_may_build(&mut self, x: bool) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[11..].as_mut_ptr(),
        core::mem::size_of::<<bool as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn instabuild(&self) -> bool {
    let mut mem = core::mem::MaybeUninit::<<bool as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[12..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<bool as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_instabuild(&mut self, x: bool) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[12..].as_mut_ptr(),
        core::mem::size_of::<<bool as EndianScalar>::Scalar>(),
      );
    }
  }

}

// struct Vector2f, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Vector2f(pub [u8; 8]);
impl Default for Vector2f { 
  fn default() -> Self { 
    Self([0; 8])
  }
}
impl core::fmt::Debug for Vector2f {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Vector2f")
      .field("x", &self.x())
      .field("y", &self.y())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Vector2f {}
impl<'a> flatbuffers::Follow<'a> for Vector2f {
  type Inner = &'a Vector2f;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Vector2f>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Vector2f {
  type Inner = &'a Vector2f;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Vector2f>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Vector2f {
    type Output = Vector2f;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Vector2f as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Vector2f {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Vector2f {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    x: f32,
    y: f32,
  ) -> Self {
    let mut s = Self([0; 8]);
    s.set_x(x);
    s.set_y(y);
    s
  }

  pub fn x(&self) -> f32 {
    let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_x(&mut self, x: f32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn y(&self) -> f32 {
    let mut mem = core::mem::MaybeUninit::<<f32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[4..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_y(&mut self, x: f32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[4..].as_mut_ptr(),
        core::mem::size_of::<<f32 as EndianScalar>::Scalar>(),
      );
    }
  }

}

// struct Vector3d, aligned to 8
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Vector3d(pub [u8; 24]);
impl Default for Vector3d { 
  fn default() -> Self { 
    Self([0; 24])
  }
}
impl core::fmt::Debug for Vector3d {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Vector3d")
      .field("x", &self.x())
      .field("y", &self.y())
      .field("z", &self.z())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Vector3d {}
impl<'a> flatbuffers::Follow<'a> for Vector3d {
  type Inner = &'a Vector3d;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Vector3d>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Vector3d {
  type Inner = &'a Vector3d;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Vector3d>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Vector3d {
    type Output = Vector3d;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Vector3d as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Vector3d {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Vector3d {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    x: f64,
    y: f64,
    z: f64,
  ) -> Self {
    let mut s = Self([0; 24]);
    s.set_x(x);
    s.set_y(y);
    s.set_z(z);
    s
  }

  pub fn x(&self) -> f64 {
    let mut mem = core::mem::MaybeUninit::<<f64 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_x(&mut self, x: f64) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn y(&self) -> f64 {
    let mut mem = core::mem::MaybeUninit::<<f64 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[8..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_y(&mut self, x: f64) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[8..].as_mut_ptr(),
        core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn z(&self) -> f64 {
    let mut mem = core::mem::MaybeUninit::<<f64 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[16..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_z(&mut self, x: f64) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[16..].as_mut_ptr(),
        core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
      );
    }
  }

}

// struct Uuid, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Uuid(pub [u8; 16]);
impl Default for Uuid { 
  fn default() -> Self { 
    Self([0; 16])
  }
}
impl core::fmt::Debug for Uuid {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Uuid")
      .field("x0", &self.x0())
      .field("x1", &self.x1())
      .field("x2", &self.x2())
      .field("x3", &self.x3())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Uuid {}
impl<'a> flatbuffers::Follow<'a> for Uuid {
  type Inner = &'a Uuid;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Uuid>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Uuid {
  type Inner = &'a Uuid;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Uuid>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Uuid {
    type Output = Uuid;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Uuid as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Uuid {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Uuid {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    x0: u32,
    x1: u32,
    x2: u32,
    x3: u32,
  ) -> Self {
    let mut s = Self([0; 16]);
    s.set_x0(x0);
    s.set_x1(x1);
    s.set_x2(x2);
    s.set_x3(x3);
    s
  }

  pub fn x0(&self) -> u32 {
    let mut mem = core::mem::MaybeUninit::<<u32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_x0(&mut self, x: u32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn x1(&self) -> u32 {
    let mut mem = core::mem::MaybeUninit::<<u32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[4..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_x1(&mut self, x: u32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[4..].as_mut_ptr(),
        core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn x2(&self) -> u32 {
    let mut mem = core::mem::MaybeUninit::<<u32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[8..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_x2(&mut self, x: u32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[8..].as_mut_ptr(),
        core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn x3(&self) -> u32 {
    let mut mem = core::mem::MaybeUninit::<<u32 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[12..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_x3(&mut self, x: u32) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[12..].as_mut_ptr(),
        core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
      );
    }
  }

}

pub enum ItemOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Item<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Item<'a> {
  type Inner = Item<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Item<'a> {
  pub const VT_COUNT: flatbuffers::VOffsetT = 4;
  pub const VT_SLOT: flatbuffers::VOffsetT = 6;
  pub const VT_ID: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Item { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ItemArgs<'args>
  ) -> flatbuffers::WIPOffset<Item<'bldr>> {
    let mut builder = ItemBuilder::new(_fbb);
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_slot(args.slot);
    builder.add_count(args.count);
    builder.finish()
  }


  #[inline]
  pub fn count(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(Item::VT_COUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn slot(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(Item::VT_SLOT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Item::VT_ID, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Item<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i8>("count", Self::VT_COUNT, false)?
     .visit_field::<u8>("slot", Self::VT_SLOT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
     .finish();
    Ok(())
  }
}
pub struct ItemArgs<'a> {
    pub count: i8,
    pub slot: u8,
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ItemArgs<'a> {
  #[inline]
  fn default() -> Self {
    ItemArgs {
      count: 0,
      slot: 0,
      id: None, // required field
    }
  }
}

pub struct ItemBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ItemBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_count(&mut self, count: i8) {
    self.fbb_.push_slot::<i8>(Item::VT_COUNT, count, 0);
  }
  #[inline]
  pub fn add_slot(&mut self, slot: u8) {
    self.fbb_.push_slot::<u8>(Item::VT_SLOT, slot, 0);
  }
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Item::VT_ID, id);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ItemBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ItemBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Item<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Item::VT_ID,"id");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Item<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Item");
      ds.field("count", &self.count());
      ds.field("slot", &self.slot());
      ds.field("id", &self.id());
      ds.finish()
  }
}
pub enum EntityOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Entity<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Entity<'a> {
  type Inner = Entity<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Entity<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_POS: flatbuffers::VOffsetT = 6;
  pub const VT_MOTION: flatbuffers::VOffsetT = 8;
  pub const VT_ROTATION: flatbuffers::VOffsetT = 10;
  pub const VT_FALL_DISTANCE: flatbuffers::VOffsetT = 12;
  pub const VT_FIRE: flatbuffers::VOffsetT = 14;
  pub const VT_AIR: flatbuffers::VOffsetT = 16;
  pub const VT_ON_GROUND: flatbuffers::VOffsetT = 18;
  pub const VT_NO_GRAVITY: flatbuffers::VOffsetT = 20;
  pub const VT_INVULNERABLE: flatbuffers::VOffsetT = 22;
  pub const VT_PORTAL_COOLDOWN: flatbuffers::VOffsetT = 24;
  pub const VT_UUID: flatbuffers::VOffsetT = 26;
  pub const VT_CUSTOM_NAME: flatbuffers::VOffsetT = 28;
  pub const VT_CUSTOM_NAME_VISIBLE: flatbuffers::VOffsetT = 30;
  pub const VT_SILENT: flatbuffers::VOffsetT = 32;
  pub const VT_GLOWING: flatbuffers::VOffsetT = 34;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Entity { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args EntityArgs<'args>
  ) -> flatbuffers::WIPOffset<Entity<'bldr>> {
    let mut builder = EntityBuilder::new(_fbb);
    if let Some(x) = args.custom_name { builder.add_custom_name(x); }
    if let Some(x) = args.uuid { builder.add_uuid(x); }
    builder.add_portal_cooldown(args.portal_cooldown);
    builder.add_fall_distance(args.fall_distance);
    if let Some(x) = args.rotation { builder.add_rotation(x); }
    if let Some(x) = args.motion { builder.add_motion(x); }
    if let Some(x) = args.pos { builder.add_pos(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_air(args.air);
    builder.add_fire(args.fire);
    builder.add_glowing(args.glowing);
    builder.add_silent(args.silent);
    builder.add_custom_name_visible(args.custom_name_visible);
    builder.add_invulnerable(args.invulnerable);
    builder.add_no_gravity(args.no_gravity);
    builder.add_on_ground(args.on_ground);
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Entity::VT_ID, None).unwrap()}
  }
  #[inline]
  pub fn pos(&self) -> &'a Vector3d {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector3d>(Entity::VT_POS, None).unwrap()}
  }
  #[inline]
  pub fn motion(&self) -> &'a Vector3d {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector3d>(Entity::VT_MOTION, None).unwrap()}
  }
  #[inline]
  pub fn rotation(&self) -> &'a Vector2f {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector2f>(Entity::VT_ROTATION, None).unwrap()}
  }
  #[inline]
  pub fn fall_distance(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Entity::VT_FALL_DISTANCE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn fire(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(Entity::VT_FIRE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn air(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(Entity::VT_AIR, Some(0)).unwrap()}
  }
  #[inline]
  pub fn on_ground(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Entity::VT_ON_GROUND, Some(false)).unwrap()}
  }
  #[inline]
  pub fn no_gravity(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Entity::VT_NO_GRAVITY, Some(false)).unwrap()}
  }
  #[inline]
  pub fn invulnerable(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Entity::VT_INVULNERABLE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn portal_cooldown(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Entity::VT_PORTAL_COOLDOWN, Some(0)).unwrap()}
  }
  #[inline]
  pub fn uuid(&self) -> &'a Uuid {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Uuid>(Entity::VT_UUID, None).unwrap()}
  }
  #[inline]
  pub fn custom_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Entity::VT_CUSTOM_NAME, None)}
  }
  #[inline]
  pub fn custom_name_visible(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Entity::VT_CUSTOM_NAME_VISIBLE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn silent(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Entity::VT_SILENT, Some(false)).unwrap()}
  }
  #[inline]
  pub fn glowing(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Entity::VT_GLOWING, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Entity<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
     .visit_field::<Vector3d>("pos", Self::VT_POS, true)?
     .visit_field::<Vector3d>("motion", Self::VT_MOTION, true)?
     .visit_field::<Vector2f>("rotation", Self::VT_ROTATION, true)?
     .visit_field::<f32>("fall_distance", Self::VT_FALL_DISTANCE, false)?
     .visit_field::<u16>("fire", Self::VT_FIRE, false)?
     .visit_field::<u16>("air", Self::VT_AIR, false)?
     .visit_field::<bool>("on_ground", Self::VT_ON_GROUND, false)?
     .visit_field::<bool>("no_gravity", Self::VT_NO_GRAVITY, false)?
     .visit_field::<bool>("invulnerable", Self::VT_INVULNERABLE, false)?
     .visit_field::<i32>("portal_cooldown", Self::VT_PORTAL_COOLDOWN, false)?
     .visit_field::<Uuid>("uuid", Self::VT_UUID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("custom_name", Self::VT_CUSTOM_NAME, false)?
     .visit_field::<bool>("custom_name_visible", Self::VT_CUSTOM_NAME_VISIBLE, false)?
     .visit_field::<bool>("silent", Self::VT_SILENT, false)?
     .visit_field::<bool>("glowing", Self::VT_GLOWING, false)?
     .finish();
    Ok(())
  }
}
pub struct EntityArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub pos: Option<&'a Vector3d>,
    pub motion: Option<&'a Vector3d>,
    pub rotation: Option<&'a Vector2f>,
    pub fall_distance: f32,
    pub fire: u16,
    pub air: u16,
    pub on_ground: bool,
    pub no_gravity: bool,
    pub invulnerable: bool,
    pub portal_cooldown: i32,
    pub uuid: Option<&'a Uuid>,
    pub custom_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub custom_name_visible: bool,
    pub silent: bool,
    pub glowing: bool,
}
impl<'a> Default for EntityArgs<'a> {
  #[inline]
  fn default() -> Self {
    EntityArgs {
      id: None, // required field
      pos: None, // required field
      motion: None, // required field
      rotation: None, // required field
      fall_distance: 0.0,
      fire: 0,
      air: 0,
      on_ground: false,
      no_gravity: false,
      invulnerable: false,
      portal_cooldown: 0,
      uuid: None, // required field
      custom_name: None,
      custom_name_visible: false,
      silent: false,
      glowing: false,
    }
  }
}

pub struct EntityBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EntityBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Entity::VT_ID, id);
  }
  #[inline]
  pub fn add_pos(&mut self, pos: &Vector3d) {
    self.fbb_.push_slot_always::<&Vector3d>(Entity::VT_POS, pos);
  }
  #[inline]
  pub fn add_motion(&mut self, motion: &Vector3d) {
    self.fbb_.push_slot_always::<&Vector3d>(Entity::VT_MOTION, motion);
  }
  #[inline]
  pub fn add_rotation(&mut self, rotation: &Vector2f) {
    self.fbb_.push_slot_always::<&Vector2f>(Entity::VT_ROTATION, rotation);
  }
  #[inline]
  pub fn add_fall_distance(&mut self, fall_distance: f32) {
    self.fbb_.push_slot::<f32>(Entity::VT_FALL_DISTANCE, fall_distance, 0.0);
  }
  #[inline]
  pub fn add_fire(&mut self, fire: u16) {
    self.fbb_.push_slot::<u16>(Entity::VT_FIRE, fire, 0);
  }
  #[inline]
  pub fn add_air(&mut self, air: u16) {
    self.fbb_.push_slot::<u16>(Entity::VT_AIR, air, 0);
  }
  #[inline]
  pub fn add_on_ground(&mut self, on_ground: bool) {
    self.fbb_.push_slot::<bool>(Entity::VT_ON_GROUND, on_ground, false);
  }
  #[inline]
  pub fn add_no_gravity(&mut self, no_gravity: bool) {
    self.fbb_.push_slot::<bool>(Entity::VT_NO_GRAVITY, no_gravity, false);
  }
  #[inline]
  pub fn add_invulnerable(&mut self, invulnerable: bool) {
    self.fbb_.push_slot::<bool>(Entity::VT_INVULNERABLE, invulnerable, false);
  }
  #[inline]
  pub fn add_portal_cooldown(&mut self, portal_cooldown: i32) {
    self.fbb_.push_slot::<i32>(Entity::VT_PORTAL_COOLDOWN, portal_cooldown, 0);
  }
  #[inline]
  pub fn add_uuid(&mut self, uuid: &Uuid) {
    self.fbb_.push_slot_always::<&Uuid>(Entity::VT_UUID, uuid);
  }
  #[inline]
  pub fn add_custom_name(&mut self, custom_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Entity::VT_CUSTOM_NAME, custom_name);
  }
  #[inline]
  pub fn add_custom_name_visible(&mut self, custom_name_visible: bool) {
    self.fbb_.push_slot::<bool>(Entity::VT_CUSTOM_NAME_VISIBLE, custom_name_visible, false);
  }
  #[inline]
  pub fn add_silent(&mut self, silent: bool) {
    self.fbb_.push_slot::<bool>(Entity::VT_SILENT, silent, false);
  }
  #[inline]
  pub fn add_glowing(&mut self, glowing: bool) {
    self.fbb_.push_slot::<bool>(Entity::VT_GLOWING, glowing, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> EntityBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    EntityBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Entity<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Entity::VT_ID,"id");
    self.fbb_.required(o, Entity::VT_POS,"pos");
    self.fbb_.required(o, Entity::VT_MOTION,"motion");
    self.fbb_.required(o, Entity::VT_ROTATION,"rotation");
    self.fbb_.required(o, Entity::VT_UUID,"uuid");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Entity<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Entity");
      ds.field("id", &self.id());
      ds.field("pos", &self.pos());
      ds.field("motion", &self.motion());
      ds.field("rotation", &self.rotation());
      ds.field("fall_distance", &self.fall_distance());
      ds.field("fire", &self.fire());
      ds.field("air", &self.air());
      ds.field("on_ground", &self.on_ground());
      ds.field("no_gravity", &self.no_gravity());
      ds.field("invulnerable", &self.invulnerable());
      ds.field("portal_cooldown", &self.portal_cooldown());
      ds.field("uuid", &self.uuid());
      ds.field("custom_name", &self.custom_name());
      ds.field("custom_name_visible", &self.custom_name_visible());
      ds.field("silent", &self.silent());
      ds.field("glowing", &self.glowing());
      ds.finish()
  }
}
pub enum RecipeBookOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RecipeBook<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RecipeBook<'a> {
  type Inner = RecipeBook<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RecipeBook<'a> {
  pub const VT_RECIPES: flatbuffers::VOffsetT = 4;
  pub const VT_TO_BE_DISPLAYED: flatbuffers::VOffsetT = 6;
  pub const VT_IS_FILTERING_CRAFTABLE: flatbuffers::VOffsetT = 8;
  pub const VT_IS_GUI_OPEN: flatbuffers::VOffsetT = 10;
  pub const VT_IS_FURNACE_FILTERING_CRAFTABLE: flatbuffers::VOffsetT = 12;
  pub const VT_IS_FURNACE_GUI_OPEN: flatbuffers::VOffsetT = 14;
  pub const VT_IS_BLASTING_FURNACE_FILTERING_CRAFTABLE: flatbuffers::VOffsetT = 16;
  pub const VT_IS_BLASTING_FURNACE_GUI_OPEN: flatbuffers::VOffsetT = 18;
  pub const VT_IS_SMOKER_FILTERING_CRAFTABLE: flatbuffers::VOffsetT = 20;
  pub const VT_IS_SMOKER_GUI_OPEN: flatbuffers::VOffsetT = 22;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RecipeBook { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RecipeBookArgs<'args>
  ) -> flatbuffers::WIPOffset<RecipeBook<'bldr>> {
    let mut builder = RecipeBookBuilder::new(_fbb);
    if let Some(x) = args.to_be_displayed { builder.add_to_be_displayed(x); }
    if let Some(x) = args.recipes { builder.add_recipes(x); }
    builder.add_is_smoker_gui_open(args.is_smoker_gui_open);
    builder.add_is_smoker_filtering_craftable(args.is_smoker_filtering_craftable);
    builder.add_is_blasting_furnace_gui_open(args.is_blasting_furnace_gui_open);
    builder.add_is_blasting_furnace_filtering_craftable(args.is_blasting_furnace_filtering_craftable);
    builder.add_is_furnace_gui_open(args.is_furnace_gui_open);
    builder.add_is_furnace_filtering_craftable(args.is_furnace_filtering_craftable);
    builder.add_is_gui_open(args.is_gui_open);
    builder.add_is_filtering_craftable(args.is_filtering_craftable);
    builder.finish()
  }


  #[inline]
  pub fn recipes(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(RecipeBook::VT_RECIPES, None).unwrap()}
  }
  #[inline]
  pub fn to_be_displayed(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(RecipeBook::VT_TO_BE_DISPLAYED, None).unwrap()}
  }
  #[inline]
  pub fn is_filtering_craftable(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(RecipeBook::VT_IS_FILTERING_CRAFTABLE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn is_gui_open(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(RecipeBook::VT_IS_GUI_OPEN, Some(false)).unwrap()}
  }
  #[inline]
  pub fn is_furnace_filtering_craftable(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(RecipeBook::VT_IS_FURNACE_FILTERING_CRAFTABLE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn is_furnace_gui_open(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(RecipeBook::VT_IS_FURNACE_GUI_OPEN, Some(false)).unwrap()}
  }
  #[inline]
  pub fn is_blasting_furnace_filtering_craftable(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(RecipeBook::VT_IS_BLASTING_FURNACE_FILTERING_CRAFTABLE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn is_blasting_furnace_gui_open(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(RecipeBook::VT_IS_BLASTING_FURNACE_GUI_OPEN, Some(false)).unwrap()}
  }
  #[inline]
  pub fn is_smoker_filtering_craftable(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(RecipeBook::VT_IS_SMOKER_FILTERING_CRAFTABLE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn is_smoker_gui_open(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(RecipeBook::VT_IS_SMOKER_GUI_OPEN, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for RecipeBook<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("recipes", Self::VT_RECIPES, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("to_be_displayed", Self::VT_TO_BE_DISPLAYED, true)?
     .visit_field::<bool>("is_filtering_craftable", Self::VT_IS_FILTERING_CRAFTABLE, false)?
     .visit_field::<bool>("is_gui_open", Self::VT_IS_GUI_OPEN, false)?
     .visit_field::<bool>("is_furnace_filtering_craftable", Self::VT_IS_FURNACE_FILTERING_CRAFTABLE, false)?
     .visit_field::<bool>("is_furnace_gui_open", Self::VT_IS_FURNACE_GUI_OPEN, false)?
     .visit_field::<bool>("is_blasting_furnace_filtering_craftable", Self::VT_IS_BLASTING_FURNACE_FILTERING_CRAFTABLE, false)?
     .visit_field::<bool>("is_blasting_furnace_gui_open", Self::VT_IS_BLASTING_FURNACE_GUI_OPEN, false)?
     .visit_field::<bool>("is_smoker_filtering_craftable", Self::VT_IS_SMOKER_FILTERING_CRAFTABLE, false)?
     .visit_field::<bool>("is_smoker_gui_open", Self::VT_IS_SMOKER_GUI_OPEN, false)?
     .finish();
    Ok(())
  }
}
pub struct RecipeBookArgs<'a> {
    pub recipes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub to_be_displayed: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub is_filtering_craftable: bool,
    pub is_gui_open: bool,
    pub is_furnace_filtering_craftable: bool,
    pub is_furnace_gui_open: bool,
    pub is_blasting_furnace_filtering_craftable: bool,
    pub is_blasting_furnace_gui_open: bool,
    pub is_smoker_filtering_craftable: bool,
    pub is_smoker_gui_open: bool,
}
impl<'a> Default for RecipeBookArgs<'a> {
  #[inline]
  fn default() -> Self {
    RecipeBookArgs {
      recipes: None, // required field
      to_be_displayed: None, // required field
      is_filtering_craftable: false,
      is_gui_open: false,
      is_furnace_filtering_craftable: false,
      is_furnace_gui_open: false,
      is_blasting_furnace_filtering_craftable: false,
      is_blasting_furnace_gui_open: false,
      is_smoker_filtering_craftable: false,
      is_smoker_gui_open: false,
    }
  }
}

pub struct RecipeBookBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RecipeBookBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_recipes(&mut self, recipes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RecipeBook::VT_RECIPES, recipes);
  }
  #[inline]
  pub fn add_to_be_displayed(&mut self, to_be_displayed: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RecipeBook::VT_TO_BE_DISPLAYED, to_be_displayed);
  }
  #[inline]
  pub fn add_is_filtering_craftable(&mut self, is_filtering_craftable: bool) {
    self.fbb_.push_slot::<bool>(RecipeBook::VT_IS_FILTERING_CRAFTABLE, is_filtering_craftable, false);
  }
  #[inline]
  pub fn add_is_gui_open(&mut self, is_gui_open: bool) {
    self.fbb_.push_slot::<bool>(RecipeBook::VT_IS_GUI_OPEN, is_gui_open, false);
  }
  #[inline]
  pub fn add_is_furnace_filtering_craftable(&mut self, is_furnace_filtering_craftable: bool) {
    self.fbb_.push_slot::<bool>(RecipeBook::VT_IS_FURNACE_FILTERING_CRAFTABLE, is_furnace_filtering_craftable, false);
  }
  #[inline]
  pub fn add_is_furnace_gui_open(&mut self, is_furnace_gui_open: bool) {
    self.fbb_.push_slot::<bool>(RecipeBook::VT_IS_FURNACE_GUI_OPEN, is_furnace_gui_open, false);
  }
  #[inline]
  pub fn add_is_blasting_furnace_filtering_craftable(&mut self, is_blasting_furnace_filtering_craftable: bool) {
    self.fbb_.push_slot::<bool>(RecipeBook::VT_IS_BLASTING_FURNACE_FILTERING_CRAFTABLE, is_blasting_furnace_filtering_craftable, false);
  }
  #[inline]
  pub fn add_is_blasting_furnace_gui_open(&mut self, is_blasting_furnace_gui_open: bool) {
    self.fbb_.push_slot::<bool>(RecipeBook::VT_IS_BLASTING_FURNACE_GUI_OPEN, is_blasting_furnace_gui_open, false);
  }
  #[inline]
  pub fn add_is_smoker_filtering_craftable(&mut self, is_smoker_filtering_craftable: bool) {
    self.fbb_.push_slot::<bool>(RecipeBook::VT_IS_SMOKER_FILTERING_CRAFTABLE, is_smoker_filtering_craftable, false);
  }
  #[inline]
  pub fn add_is_smoker_gui_open(&mut self, is_smoker_gui_open: bool) {
    self.fbb_.push_slot::<bool>(RecipeBook::VT_IS_SMOKER_GUI_OPEN, is_smoker_gui_open, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RecipeBookBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RecipeBookBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RecipeBook<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, RecipeBook::VT_RECIPES,"recipes");
    self.fbb_.required(o, RecipeBook::VT_TO_BE_DISPLAYED,"to_be_displayed");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RecipeBook<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RecipeBook");
      ds.field("recipes", &self.recipes());
      ds.field("to_be_displayed", &self.to_be_displayed());
      ds.field("is_filtering_craftable", &self.is_filtering_craftable());
      ds.field("is_gui_open", &self.is_gui_open());
      ds.field("is_furnace_filtering_craftable", &self.is_furnace_filtering_craftable());
      ds.field("is_furnace_gui_open", &self.is_furnace_gui_open());
      ds.field("is_blasting_furnace_filtering_craftable", &self.is_blasting_furnace_filtering_craftable());
      ds.field("is_blasting_furnace_gui_open", &self.is_blasting_furnace_gui_open());
      ds.field("is_smoker_filtering_craftable", &self.is_smoker_filtering_craftable());
      ds.field("is_smoker_gui_open", &self.is_smoker_gui_open());
      ds.finish()
  }
}
pub enum VehicleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Vehicle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Vehicle<'a> {
  type Inner = Vehicle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Vehicle<'a> {
  pub const VT_PARAM_0: flatbuffers::VOffsetT = 4;
  pub const VT_PARAM_1: flatbuffers::VOffsetT = 6;
  pub const VT_PARAM_2: flatbuffers::VOffsetT = 8;
  pub const VT_PARAM_3: flatbuffers::VOffsetT = 10;
  pub const VT_ENTITY: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Vehicle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args VehicleArgs<'args>
  ) -> flatbuffers::WIPOffset<Vehicle<'bldr>> {
    let mut builder = VehicleBuilder::new(_fbb);
    if let Some(x) = args.entity { builder.add_entity(x); }
    builder.add_param_3(args.param_3);
    builder.add_param_2(args.param_2);
    builder.add_param_1(args.param_1);
    builder.add_param_0(args.param_0);
    builder.finish()
  }


  #[inline]
  pub fn param_0(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Vehicle::VT_PARAM_0, Some(0)).unwrap()}
  }
  #[inline]
  pub fn param_1(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Vehicle::VT_PARAM_1, Some(0)).unwrap()}
  }
  #[inline]
  pub fn param_2(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Vehicle::VT_PARAM_2, Some(0)).unwrap()}
  }
  #[inline]
  pub fn param_3(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Vehicle::VT_PARAM_3, Some(0)).unwrap()}
  }
  #[inline]
  pub fn entity(&self) -> Entity<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Entity>>(Vehicle::VT_ENTITY, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Vehicle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("param_0", Self::VT_PARAM_0, false)?
     .visit_field::<u32>("param_1", Self::VT_PARAM_1, false)?
     .visit_field::<u32>("param_2", Self::VT_PARAM_2, false)?
     .visit_field::<u32>("param_3", Self::VT_PARAM_3, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Entity>>("entity", Self::VT_ENTITY, true)?
     .finish();
    Ok(())
  }
}
pub struct VehicleArgs<'a> {
    pub param_0: u32,
    pub param_1: u32,
    pub param_2: u32,
    pub param_3: u32,
    pub entity: Option<flatbuffers::WIPOffset<Entity<'a>>>,
}
impl<'a> Default for VehicleArgs<'a> {
  #[inline]
  fn default() -> Self {
    VehicleArgs {
      param_0: 0,
      param_1: 0,
      param_2: 0,
      param_3: 0,
      entity: None, // required field
    }
  }
}

pub struct VehicleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> VehicleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_param_0(&mut self, param_0: u32) {
    self.fbb_.push_slot::<u32>(Vehicle::VT_PARAM_0, param_0, 0);
  }
  #[inline]
  pub fn add_param_1(&mut self, param_1: u32) {
    self.fbb_.push_slot::<u32>(Vehicle::VT_PARAM_1, param_1, 0);
  }
  #[inline]
  pub fn add_param_2(&mut self, param_2: u32) {
    self.fbb_.push_slot::<u32>(Vehicle::VT_PARAM_2, param_2, 0);
  }
  #[inline]
  pub fn add_param_3(&mut self, param_3: u32) {
    self.fbb_.push_slot::<u32>(Vehicle::VT_PARAM_3, param_3, 0);
  }
  #[inline]
  pub fn add_entity(&mut self, entity: flatbuffers::WIPOffset<Entity<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Entity>>(Vehicle::VT_ENTITY, entity);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> VehicleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    VehicleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Vehicle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Vehicle::VT_ENTITY,"entity");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Vehicle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Vehicle");
      ds.field("param_0", &self.param_0());
      ds.field("param_1", &self.param_1());
      ds.field("param_2", &self.param_2());
      ds.field("param_3", &self.param_3());
      ds.field("entity", &self.entity());
      ds.finish()
  }
}
pub enum PlayerOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Player<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Player<'a> {
  type Inner = Player<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Player<'a> {
  pub const VT_GAME_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_PREVIOUS_GAME_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_SCORE: flatbuffers::VOffsetT = 8;
  pub const VT_DIMENSION: flatbuffers::VOffsetT = 10;
  pub const VT_SELECTED_ITEM_SLOT: flatbuffers::VOffsetT = 12;
  pub const VT_SELECTED_ITEM: flatbuffers::VOffsetT = 14;
  pub const VT_SPAWN_DIMENSION: flatbuffers::VOffsetT = 16;
  pub const VT_SPAWN_X: flatbuffers::VOffsetT = 18;
  pub const VT_SPAWN_Y: flatbuffers::VOffsetT = 20;
  pub const VT_SPAWN_Z: flatbuffers::VOffsetT = 22;
  pub const VT_SPAWN_FORCED: flatbuffers::VOffsetT = 24;
  pub const VT_SLEEP_TIMER: flatbuffers::VOffsetT = 26;
  pub const VT_FOOD_EXHAUSTION_LEVEL: flatbuffers::VOffsetT = 28;
  pub const VT_FOOD_SATURATION_LEVEL: flatbuffers::VOffsetT = 30;
  pub const VT_FOOD_TICK_TIMER: flatbuffers::VOffsetT = 32;
  pub const VT_XP_LEVEL: flatbuffers::VOffsetT = 34;
  pub const VT_XP_P: flatbuffers::VOffsetT = 36;
  pub const VT_XP_TOTAL: flatbuffers::VOffsetT = 38;
  pub const VT_XP_SEED: flatbuffers::VOffsetT = 40;
  pub const VT_INVENTORY: flatbuffers::VOffsetT = 42;
  pub const VT_ENDER_ITEMS: flatbuffers::VOffsetT = 44;
  pub const VT_ABILITIES: flatbuffers::VOffsetT = 46;
  pub const VT_ENTERED_NETHER_POSITION: flatbuffers::VOffsetT = 48;
  pub const VT_ROOT_VEHICLE: flatbuffers::VOffsetT = 50;
  pub const VT_SHOULDER_ENTITY_LEFT: flatbuffers::VOffsetT = 52;
  pub const VT_SHOULDER_ENTITY_RIGHT: flatbuffers::VOffsetT = 54;
  pub const VT_SEEN_CREDITS: flatbuffers::VOffsetT = 56;
  pub const VT_RECIPE_BOOK: flatbuffers::VOffsetT = 58;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Player { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PlayerArgs<'args>
  ) -> flatbuffers::WIPOffset<Player<'bldr>> {
    let mut builder = PlayerBuilder::new(_fbb);
    builder.add_spawn_z(args.spawn_z);
    builder.add_spawn_y(args.spawn_y);
    builder.add_spawn_x(args.spawn_x);
    builder.add_score(args.score);
    if let Some(x) = args.recipe_book { builder.add_recipe_book(x); }
    if let Some(x) = args.shoulder_entity_right { builder.add_shoulder_entity_right(x); }
    if let Some(x) = args.shoulder_entity_left { builder.add_shoulder_entity_left(x); }
    if let Some(x) = args.root_vehicle { builder.add_root_vehicle(x); }
    if let Some(x) = args.entered_nether_position { builder.add_entered_nether_position(x); }
    if let Some(x) = args.abilities { builder.add_abilities(x); }
    if let Some(x) = args.ender_items { builder.add_ender_items(x); }
    if let Some(x) = args.inventory { builder.add_inventory(x); }
    builder.add_xp_seed(args.xp_seed);
    builder.add_xp_total(args.xp_total);
    builder.add_xp_p(args.xp_p);
    builder.add_xp_level(args.xp_level);
    builder.add_food_tick_timer(args.food_tick_timer);
    builder.add_food_saturation_level(args.food_saturation_level);
    builder.add_food_exhaustion_level(args.food_exhaustion_level);
    if let Some(x) = args.spawn_dimension { builder.add_spawn_dimension(x); }
    if let Some(x) = args.selected_item { builder.add_selected_item(x); }
    builder.add_selected_item_slot(args.selected_item_slot);
    if let Some(x) = args.dimension { builder.add_dimension(x); }
    builder.add_sleep_timer(args.sleep_timer);
    builder.add_seen_credits(args.seen_credits);
    builder.add_spawn_forced(args.spawn_forced);
    builder.add_previous_game_type(args.previous_game_type);
    builder.add_game_type(args.game_type);
    builder.finish()
  }


  #[inline]
  pub fn game_type(&self) -> GameType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<GameType>(Player::VT_GAME_TYPE, Some(GameType::Survival)).unwrap()}
  }
  #[inline]
  pub fn previous_game_type(&self) -> GameType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<GameType>(Player::VT_PREVIOUS_GAME_TYPE, Some(GameType::Survival)).unwrap()}
  }
  #[inline]
  pub fn score(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(Player::VT_SCORE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn dimension(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Player::VT_DIMENSION, None).unwrap()}
  }
  #[inline]
  pub fn selected_item_slot(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Player::VT_SELECTED_ITEM_SLOT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn selected_item(&self) -> Item<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Item>>(Player::VT_SELECTED_ITEM, None).unwrap()}
  }
  #[inline]
  pub fn spawn_dimension(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Player::VT_SPAWN_DIMENSION, None)}
  }
  #[inline]
  pub fn spawn_x(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(Player::VT_SPAWN_X, Some(0)).unwrap()}
  }
  #[inline]
  pub fn spawn_y(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(Player::VT_SPAWN_Y, Some(0)).unwrap()}
  }
  #[inline]
  pub fn spawn_z(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(Player::VT_SPAWN_Z, Some(0)).unwrap()}
  }
  #[inline]
  pub fn spawn_forced(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Player::VT_SPAWN_FORCED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn sleep_timer(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(Player::VT_SLEEP_TIMER, Some(0)).unwrap()}
  }
  #[inline]
  pub fn food_exhaustion_level(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Player::VT_FOOD_EXHAUSTION_LEVEL, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn food_saturation_level(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Player::VT_FOOD_SATURATION_LEVEL, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn food_tick_timer(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Player::VT_FOOD_TICK_TIMER, Some(0)).unwrap()}
  }
  #[inline]
  pub fn xp_level(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Player::VT_XP_LEVEL, Some(0)).unwrap()}
  }
  #[inline]
  pub fn xp_p(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Player::VT_XP_P, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn xp_total(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Player::VT_XP_TOTAL, Some(0)).unwrap()}
  }
  #[inline]
  pub fn xp_seed(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Player::VT_XP_SEED, Some(0)).unwrap()}
  }
  #[inline]
  pub fn inventory(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Item<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Item>>>>(Player::VT_INVENTORY, None).unwrap()}
  }
  #[inline]
  pub fn ender_items(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Item<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Item>>>>(Player::VT_ENDER_ITEMS, None).unwrap()}
  }
  #[inline]
  pub fn abilities(&self) -> &'a Abilities {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Abilities>(Player::VT_ABILITIES, None).unwrap()}
  }
  #[inline]
  pub fn entered_nether_position(&self) -> Option<&'a Vector3d> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Vector3d>(Player::VT_ENTERED_NETHER_POSITION, None)}
  }
  #[inline]
  pub fn root_vehicle(&self) -> Option<Vehicle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Vehicle>>(Player::VT_ROOT_VEHICLE, None)}
  }
  #[inline]
  pub fn shoulder_entity_left(&self) -> Option<Entity<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Entity>>(Player::VT_SHOULDER_ENTITY_LEFT, None)}
  }
  #[inline]
  pub fn shoulder_entity_right(&self) -> Option<Entity<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Entity>>(Player::VT_SHOULDER_ENTITY_RIGHT, None)}
  }
  #[inline]
  pub fn seen_credits(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Player::VT_SEEN_CREDITS, Some(false)).unwrap()}
  }
  #[inline]
  pub fn recipe_book(&self) -> RecipeBook<'a> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<RecipeBook>>(Player::VT_RECIPE_BOOK, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Player<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<GameType>("game_type", Self::VT_GAME_TYPE, false)?
     .visit_field::<GameType>("previous_game_type", Self::VT_PREVIOUS_GAME_TYPE, false)?
     .visit_field::<i64>("score", Self::VT_SCORE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("dimension", Self::VT_DIMENSION, true)?
     .visit_field::<u32>("selected_item_slot", Self::VT_SELECTED_ITEM_SLOT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Item>>("selected_item", Self::VT_SELECTED_ITEM, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("spawn_dimension", Self::VT_SPAWN_DIMENSION, false)?
     .visit_field::<i64>("spawn_x", Self::VT_SPAWN_X, false)?
     .visit_field::<i64>("spawn_y", Self::VT_SPAWN_Y, false)?
     .visit_field::<i64>("spawn_z", Self::VT_SPAWN_Z, false)?
     .visit_field::<bool>("spawn_forced", Self::VT_SPAWN_FORCED, false)?
     .visit_field::<u16>("sleep_timer", Self::VT_SLEEP_TIMER, false)?
     .visit_field::<f32>("food_exhaustion_level", Self::VT_FOOD_EXHAUSTION_LEVEL, false)?
     .visit_field::<f32>("food_saturation_level", Self::VT_FOOD_SATURATION_LEVEL, false)?
     .visit_field::<u32>("food_tick_timer", Self::VT_FOOD_TICK_TIMER, false)?
     .visit_field::<u32>("xp_level", Self::VT_XP_LEVEL, false)?
     .visit_field::<f32>("xp_p", Self::VT_XP_P, false)?
     .visit_field::<i32>("xp_total", Self::VT_XP_TOTAL, false)?
     .visit_field::<i32>("xp_seed", Self::VT_XP_SEED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Item>>>>("inventory", Self::VT_INVENTORY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Item>>>>("ender_items", Self::VT_ENDER_ITEMS, true)?
     .visit_field::<Abilities>("abilities", Self::VT_ABILITIES, true)?
     .visit_field::<Vector3d>("entered_nether_position", Self::VT_ENTERED_NETHER_POSITION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Vehicle>>("root_vehicle", Self::VT_ROOT_VEHICLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Entity>>("shoulder_entity_left", Self::VT_SHOULDER_ENTITY_LEFT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Entity>>("shoulder_entity_right", Self::VT_SHOULDER_ENTITY_RIGHT, false)?
     .visit_field::<bool>("seen_credits", Self::VT_SEEN_CREDITS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<RecipeBook>>("recipe_book", Self::VT_RECIPE_BOOK, true)?
     .finish();
    Ok(())
  }
}
pub struct PlayerArgs<'a> {
    pub game_type: GameType,
    pub previous_game_type: GameType,
    pub score: i64,
    pub dimension: Option<flatbuffers::WIPOffset<&'a str>>,
    pub selected_item_slot: u32,
    pub selected_item: Option<flatbuffers::WIPOffset<Item<'a>>>,
    pub spawn_dimension: Option<flatbuffers::WIPOffset<&'a str>>,
    pub spawn_x: i64,
    pub spawn_y: i64,
    pub spawn_z: i64,
    pub spawn_forced: bool,
    pub sleep_timer: u16,
    pub food_exhaustion_level: f32,
    pub food_saturation_level: f32,
    pub food_tick_timer: u32,
    pub xp_level: u32,
    pub xp_p: f32,
    pub xp_total: i32,
    pub xp_seed: i32,
    pub inventory: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Item<'a>>>>>,
    pub ender_items: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Item<'a>>>>>,
    pub abilities: Option<&'a Abilities>,
    pub entered_nether_position: Option<&'a Vector3d>,
    pub root_vehicle: Option<flatbuffers::WIPOffset<Vehicle<'a>>>,
    pub shoulder_entity_left: Option<flatbuffers::WIPOffset<Entity<'a>>>,
    pub shoulder_entity_right: Option<flatbuffers::WIPOffset<Entity<'a>>>,
    pub seen_credits: bool,
    pub recipe_book: Option<flatbuffers::WIPOffset<RecipeBook<'a>>>,
}
impl<'a> Default for PlayerArgs<'a> {
  #[inline]
  fn default() -> Self {
    PlayerArgs {
      game_type: GameType::Survival,
      previous_game_type: GameType::Survival,
      score: 0,
      dimension: None, // required field
      selected_item_slot: 0,
      selected_item: None, // required field
      spawn_dimension: None,
      spawn_x: 0,
      spawn_y: 0,
      spawn_z: 0,
      spawn_forced: false,
      sleep_timer: 0,
      food_exhaustion_level: 0.0,
      food_saturation_level: 0.0,
      food_tick_timer: 0,
      xp_level: 0,
      xp_p: 0.0,
      xp_total: 0,
      xp_seed: 0,
      inventory: None, // required field
      ender_items: None, // required field
      abilities: None, // required field
      entered_nether_position: None,
      root_vehicle: None,
      shoulder_entity_left: None,
      shoulder_entity_right: None,
      seen_credits: false,
      recipe_book: None, // required field
    }
  }
}

pub struct PlayerBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PlayerBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_game_type(&mut self, game_type: GameType) {
    self.fbb_.push_slot::<GameType>(Player::VT_GAME_TYPE, game_type, GameType::Survival);
  }
  #[inline]
  pub fn add_previous_game_type(&mut self, previous_game_type: GameType) {
    self.fbb_.push_slot::<GameType>(Player::VT_PREVIOUS_GAME_TYPE, previous_game_type, GameType::Survival);
  }
  #[inline]
  pub fn add_score(&mut self, score: i64) {
    self.fbb_.push_slot::<i64>(Player::VT_SCORE, score, 0);
  }
  #[inline]
  pub fn add_dimension(&mut self, dimension: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Player::VT_DIMENSION, dimension);
  }
  #[inline]
  pub fn add_selected_item_slot(&mut self, selected_item_slot: u32) {
    self.fbb_.push_slot::<u32>(Player::VT_SELECTED_ITEM_SLOT, selected_item_slot, 0);
  }
  #[inline]
  pub fn add_selected_item(&mut self, selected_item: flatbuffers::WIPOffset<Item<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Item>>(Player::VT_SELECTED_ITEM, selected_item);
  }
  #[inline]
  pub fn add_spawn_dimension(&mut self, spawn_dimension: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Player::VT_SPAWN_DIMENSION, spawn_dimension);
  }
  #[inline]
  pub fn add_spawn_x(&mut self, spawn_x: i64) {
    self.fbb_.push_slot::<i64>(Player::VT_SPAWN_X, spawn_x, 0);
  }
  #[inline]
  pub fn add_spawn_y(&mut self, spawn_y: i64) {
    self.fbb_.push_slot::<i64>(Player::VT_SPAWN_Y, spawn_y, 0);
  }
  #[inline]
  pub fn add_spawn_z(&mut self, spawn_z: i64) {
    self.fbb_.push_slot::<i64>(Player::VT_SPAWN_Z, spawn_z, 0);
  }
  #[inline]
  pub fn add_spawn_forced(&mut self, spawn_forced: bool) {
    self.fbb_.push_slot::<bool>(Player::VT_SPAWN_FORCED, spawn_forced, false);
  }
  #[inline]
  pub fn add_sleep_timer(&mut self, sleep_timer: u16) {
    self.fbb_.push_slot::<u16>(Player::VT_SLEEP_TIMER, sleep_timer, 0);
  }
  #[inline]
  pub fn add_food_exhaustion_level(&mut self, food_exhaustion_level: f32) {
    self.fbb_.push_slot::<f32>(Player::VT_FOOD_EXHAUSTION_LEVEL, food_exhaustion_level, 0.0);
  }
  #[inline]
  pub fn add_food_saturation_level(&mut self, food_saturation_level: f32) {
    self.fbb_.push_slot::<f32>(Player::VT_FOOD_SATURATION_LEVEL, food_saturation_level, 0.0);
  }
  #[inline]
  pub fn add_food_tick_timer(&mut self, food_tick_timer: u32) {
    self.fbb_.push_slot::<u32>(Player::VT_FOOD_TICK_TIMER, food_tick_timer, 0);
  }
  #[inline]
  pub fn add_xp_level(&mut self, xp_level: u32) {
    self.fbb_.push_slot::<u32>(Player::VT_XP_LEVEL, xp_level, 0);
  }
  #[inline]
  pub fn add_xp_p(&mut self, xp_p: f32) {
    self.fbb_.push_slot::<f32>(Player::VT_XP_P, xp_p, 0.0);
  }
  #[inline]
  pub fn add_xp_total(&mut self, xp_total: i32) {
    self.fbb_.push_slot::<i32>(Player::VT_XP_TOTAL, xp_total, 0);
  }
  #[inline]
  pub fn add_xp_seed(&mut self, xp_seed: i32) {
    self.fbb_.push_slot::<i32>(Player::VT_XP_SEED, xp_seed, 0);
  }
  #[inline]
  pub fn add_inventory(&mut self, inventory: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Item<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Player::VT_INVENTORY, inventory);
  }
  #[inline]
  pub fn add_ender_items(&mut self, ender_items: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Item<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Player::VT_ENDER_ITEMS, ender_items);
  }
  #[inline]
  pub fn add_abilities(&mut self, abilities: &Abilities) {
    self.fbb_.push_slot_always::<&Abilities>(Player::VT_ABILITIES, abilities);
  }
  #[inline]
  pub fn add_entered_nether_position(&mut self, entered_nether_position: &Vector3d) {
    self.fbb_.push_slot_always::<&Vector3d>(Player::VT_ENTERED_NETHER_POSITION, entered_nether_position);
  }
  #[inline]
  pub fn add_root_vehicle(&mut self, root_vehicle: flatbuffers::WIPOffset<Vehicle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Vehicle>>(Player::VT_ROOT_VEHICLE, root_vehicle);
  }
  #[inline]
  pub fn add_shoulder_entity_left(&mut self, shoulder_entity_left: flatbuffers::WIPOffset<Entity<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Entity>>(Player::VT_SHOULDER_ENTITY_LEFT, shoulder_entity_left);
  }
  #[inline]
  pub fn add_shoulder_entity_right(&mut self, shoulder_entity_right: flatbuffers::WIPOffset<Entity<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Entity>>(Player::VT_SHOULDER_ENTITY_RIGHT, shoulder_entity_right);
  }
  #[inline]
  pub fn add_seen_credits(&mut self, seen_credits: bool) {
    self.fbb_.push_slot::<bool>(Player::VT_SEEN_CREDITS, seen_credits, false);
  }
  #[inline]
  pub fn add_recipe_book(&mut self, recipe_book: flatbuffers::WIPOffset<RecipeBook<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<RecipeBook>>(Player::VT_RECIPE_BOOK, recipe_book);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PlayerBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PlayerBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Player<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Player::VT_DIMENSION,"dimension");
    self.fbb_.required(o, Player::VT_SELECTED_ITEM,"selected_item");
    self.fbb_.required(o, Player::VT_INVENTORY,"inventory");
    self.fbb_.required(o, Player::VT_ENDER_ITEMS,"ender_items");
    self.fbb_.required(o, Player::VT_ABILITIES,"abilities");
    self.fbb_.required(o, Player::VT_RECIPE_BOOK,"recipe_book");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Player<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Player");
      ds.field("game_type", &self.game_type());
      ds.field("previous_game_type", &self.previous_game_type());
      ds.field("score", &self.score());
      ds.field("dimension", &self.dimension());
      ds.field("selected_item_slot", &self.selected_item_slot());
      ds.field("selected_item", &self.selected_item());
      ds.field("spawn_dimension", &self.spawn_dimension());
      ds.field("spawn_x", &self.spawn_x());
      ds.field("spawn_y", &self.spawn_y());
      ds.field("spawn_z", &self.spawn_z());
      ds.field("spawn_forced", &self.spawn_forced());
      ds.field("sleep_timer", &self.sleep_timer());
      ds.field("food_exhaustion_level", &self.food_exhaustion_level());
      ds.field("food_saturation_level", &self.food_saturation_level());
      ds.field("food_tick_timer", &self.food_tick_timer());
      ds.field("xp_level", &self.xp_level());
      ds.field("xp_p", &self.xp_p());
      ds.field("xp_total", &self.xp_total());
      ds.field("xp_seed", &self.xp_seed());
      ds.field("inventory", &self.inventory());
      ds.field("ender_items", &self.ender_items());
      ds.field("abilities", &self.abilities());
      ds.field("entered_nether_position", &self.entered_nether_position());
      ds.field("root_vehicle", &self.root_vehicle());
      ds.field("shoulder_entity_left", &self.shoulder_entity_left());
      ds.field("shoulder_entity_right", &self.shoulder_entity_right());
      ds.field("seen_credits", &self.seen_credits());
      ds.field("recipe_book", &self.recipe_book());
      ds.finish()
  }
}
pub enum PlayersOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Players<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Players<'a> {
  type Inner = Players<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Players<'a> {
  pub const VT_PLAYERS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Players { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PlayersArgs<'args>
  ) -> flatbuffers::WIPOffset<Players<'bldr>> {
    let mut builder = PlayersBuilder::new(_fbb);
    if let Some(x) = args.players { builder.add_players(x); }
    builder.finish()
  }


  #[inline]
  pub fn players(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Player<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Player>>>>(Players::VT_PLAYERS, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for Players<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Player>>>>("players", Self::VT_PLAYERS, true)?
     .finish();
    Ok(())
  }
}
pub struct PlayersArgs<'a> {
    pub players: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Player<'a>>>>>,
}
impl<'a> Default for PlayersArgs<'a> {
  #[inline]
  fn default() -> Self {
    PlayersArgs {
      players: None, // required field
    }
  }
}

pub struct PlayersBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PlayersBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_players(&mut self, players: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Player<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Players::VT_PLAYERS, players);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PlayersBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PlayersBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Players<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Players::VT_PLAYERS,"players");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Players<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Players");
      ds.field("players", &self.players());
      ds.finish()
  }
}
}  // pub mod minecraft_savedata

