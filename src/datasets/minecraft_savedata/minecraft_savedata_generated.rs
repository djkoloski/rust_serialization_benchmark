// automatically generated by the FlatBuffers compiler, do not modify



use std::mem;
use std::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

#[allow(unused_imports, dead_code)]
pub mod minecraft_savedata {

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;

#[allow(non_camel_case_types)]
#[repr(i8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum GameType {
  Survival = 0,
  Creative = 1,
  Adventure = 2,
  Spectator = 3,

}

pub const ENUM_MIN_GAME_TYPE: i8 = 0;
pub const ENUM_MAX_GAME_TYPE: i8 = 3;

impl<'a> flatbuffers::Follow<'a> for GameType {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for GameType {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = i8::to_le(self as i8);
    let p = &n as *const i8 as *const GameType;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = i8::from_le(self as i8);
    let p = &n as *const i8 as *const GameType;
    unsafe { *p }
  }
}

impl flatbuffers::Push for GameType {
    type Output = GameType;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<GameType>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
pub const ENUM_VALUES_GAME_TYPE:[GameType; 4] = [
  GameType::Survival,
  GameType::Creative,
  GameType::Adventure,
  GameType::Spectator
];

#[allow(non_camel_case_types)]
pub const ENUM_NAMES_GAME_TYPE:[&'static str; 4] = [
    "Survival",
    "Creative",
    "Adventure",
    "Spectator"
];

pub fn enum_name_game_type(e: GameType) -> &'static str {
  let index = e as i8;
  ENUM_NAMES_GAME_TYPE[index as usize]
}

// struct Abilities, aligned to 4
#[repr(C, align(4))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct Abilities {
  walk_speed_: f32,
  fly_speed_: f32,
  may_fly_: bool,
  flying_: bool,
  invulnerable_: bool,
  may_build_: bool,
  instabuild_: bool,
  padding0__: u8,  padding1__: u16,
} // pub struct Abilities
impl flatbuffers::SafeSliceAccess for Abilities {}
impl<'a> flatbuffers::Follow<'a> for Abilities {
  type Inner = &'a Abilities;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Abilities>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Abilities {
  type Inner = &'a Abilities;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Abilities>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Abilities {
    type Output = Abilities;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const Abilities as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b Abilities {
    type Output = Abilities;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const Abilities as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}


impl Abilities {
  pub fn new<'a>(_walk_speed: f32, _fly_speed: f32, _may_fly: bool, _flying: bool, _invulnerable: bool, _may_build: bool, _instabuild: bool) -> Self {
    Abilities {
      walk_speed_: _walk_speed.to_little_endian(),
      fly_speed_: _fly_speed.to_little_endian(),
      may_fly_: _may_fly.to_little_endian(),
      flying_: _flying.to_little_endian(),
      invulnerable_: _invulnerable.to_little_endian(),
      may_build_: _may_build.to_little_endian(),
      instabuild_: _instabuild.to_little_endian(),

      padding0__: 0,padding1__: 0,
    }
  }
  pub fn walk_speed<'a>(&'a self) -> f32 {
    self.walk_speed_.from_little_endian()
  }
  pub fn fly_speed<'a>(&'a self) -> f32 {
    self.fly_speed_.from_little_endian()
  }
  pub fn may_fly<'a>(&'a self) -> bool {
    self.may_fly_.from_little_endian()
  }
  pub fn flying<'a>(&'a self) -> bool {
    self.flying_.from_little_endian()
  }
  pub fn invulnerable<'a>(&'a self) -> bool {
    self.invulnerable_.from_little_endian()
  }
  pub fn may_build<'a>(&'a self) -> bool {
    self.may_build_.from_little_endian()
  }
  pub fn instabuild<'a>(&'a self) -> bool {
    self.instabuild_.from_little_endian()
  }
}

// struct Vector2f, aligned to 4
#[repr(C, align(4))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct Vector2f {
  x_: f32,
  y_: f32,
} // pub struct Vector2f
impl flatbuffers::SafeSliceAccess for Vector2f {}
impl<'a> flatbuffers::Follow<'a> for Vector2f {
  type Inner = &'a Vector2f;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Vector2f>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Vector2f {
  type Inner = &'a Vector2f;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Vector2f>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Vector2f {
    type Output = Vector2f;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const Vector2f as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b Vector2f {
    type Output = Vector2f;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const Vector2f as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}


impl Vector2f {
  pub fn new<'a>(_x: f32, _y: f32) -> Self {
    Vector2f {
      x_: _x.to_little_endian(),
      y_: _y.to_little_endian(),

    }
  }
  pub fn x<'a>(&'a self) -> f32 {
    self.x_.from_little_endian()
  }
  pub fn y<'a>(&'a self) -> f32 {
    self.y_.from_little_endian()
  }
}

// struct Vector3d, aligned to 8
#[repr(C, align(8))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct Vector3d {
  x_: f64,
  y_: f64,
  z_: f64,
} // pub struct Vector3d
impl flatbuffers::SafeSliceAccess for Vector3d {}
impl<'a> flatbuffers::Follow<'a> for Vector3d {
  type Inner = &'a Vector3d;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Vector3d>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Vector3d {
  type Inner = &'a Vector3d;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Vector3d>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Vector3d {
    type Output = Vector3d;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const Vector3d as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b Vector3d {
    type Output = Vector3d;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const Vector3d as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}


impl Vector3d {
  pub fn new<'a>(_x: f64, _y: f64, _z: f64) -> Self {
    Vector3d {
      x_: _x.to_little_endian(),
      y_: _y.to_little_endian(),
      z_: _z.to_little_endian(),

    }
  }
  pub fn x<'a>(&'a self) -> f64 {
    self.x_.from_little_endian()
  }
  pub fn y<'a>(&'a self) -> f64 {
    self.y_.from_little_endian()
  }
  pub fn z<'a>(&'a self) -> f64 {
    self.z_.from_little_endian()
  }
}

// struct Uuid, aligned to 4
#[repr(C, align(4))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct Uuid {
  x0_: u32,
  x1_: u32,
  x2_: u32,
  x3_: u32,
} // pub struct Uuid
impl flatbuffers::SafeSliceAccess for Uuid {}
impl<'a> flatbuffers::Follow<'a> for Uuid {
  type Inner = &'a Uuid;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Uuid>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Uuid {
  type Inner = &'a Uuid;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Uuid>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Uuid {
    type Output = Uuid;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const Uuid as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b Uuid {
    type Output = Uuid;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const Uuid as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}


impl Uuid {
  pub fn new<'a>(_x0: u32, _x1: u32, _x2: u32, _x3: u32) -> Self {
    Uuid {
      x0_: _x0.to_little_endian(),
      x1_: _x1.to_little_endian(),
      x2_: _x2.to_little_endian(),
      x3_: _x3.to_little_endian(),

    }
  }
  pub fn x0<'a>(&'a self) -> u32 {
    self.x0_.from_little_endian()
  }
  pub fn x1<'a>(&'a self) -> u32 {
    self.x1_.from_little_endian()
  }
  pub fn x2<'a>(&'a self) -> u32 {
    self.x2_.from_little_endian()
  }
  pub fn x3<'a>(&'a self) -> u32 {
    self.x3_.from_little_endian()
  }
}

pub enum ItemOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Item<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Item<'a> {
    type Inner = Item<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Item<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Item {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ItemArgs<'args>) -> flatbuffers::WIPOffset<Item<'bldr>> {
      let mut builder = ItemBuilder::new(_fbb);
      if let Some(x) = args.id { builder.add_id(x); }
      builder.add_slot(args.slot);
      builder.add_count(args.count);
      builder.finish()
    }

    pub const VT_COUNT: flatbuffers::VOffsetT = 4;
    pub const VT_SLOT: flatbuffers::VOffsetT = 6;
    pub const VT_ID: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn count(&self) -> i8 {
    self._tab.get::<i8>(Item::VT_COUNT, Some(0)).unwrap()
  }
  #[inline]
  pub fn slot(&self) -> u8 {
    self._tab.get::<u8>(Item::VT_SLOT, Some(0)).unwrap()
  }
  #[inline]
  pub fn id(&self) -> &'a str {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Item::VT_ID, None).unwrap()
  }
}

pub struct ItemArgs<'a> {
    pub count: i8,
    pub slot: u8,
    pub id: Option<flatbuffers::WIPOffset<&'a  str>>,
}
impl<'a> Default for ItemArgs<'a> {
    #[inline]
    fn default() -> Self {
        ItemArgs {
            count: 0,
            slot: 0,
            id: None, // required field
        }
    }
}
pub struct ItemBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ItemBuilder<'a, 'b> {
  #[inline]
  pub fn add_count(&mut self, count: i8) {
    self.fbb_.push_slot::<i8>(Item::VT_COUNT, count, 0);
  }
  #[inline]
  pub fn add_slot(&mut self, slot: u8) {
    self.fbb_.push_slot::<u8>(Item::VT_SLOT, slot, 0);
  }
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Item::VT_ID, id);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ItemBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ItemBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Item<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Item::VT_ID,"id");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum EntityOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Entity<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Entity<'a> {
    type Inner = Entity<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Entity<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Entity {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args EntityArgs<'args>) -> flatbuffers::WIPOffset<Entity<'bldr>> {
      let mut builder = EntityBuilder::new(_fbb);
      if let Some(x) = args.custom_name { builder.add_custom_name(x); }
      if let Some(x) = args.uuid { builder.add_uuid(x); }
      builder.add_portal_cooldown(args.portal_cooldown);
      builder.add_fall_distance(args.fall_distance);
      if let Some(x) = args.rotation { builder.add_rotation(x); }
      if let Some(x) = args.motion { builder.add_motion(x); }
      if let Some(x) = args.pos { builder.add_pos(x); }
      if let Some(x) = args.id { builder.add_id(x); }
      builder.add_air(args.air);
      builder.add_fire(args.fire);
      builder.add_glowing(args.glowing);
      builder.add_silent(args.silent);
      builder.add_custom_name_visible(args.custom_name_visible);
      builder.add_invulnerable(args.invulnerable);
      builder.add_no_gravity(args.no_gravity);
      builder.add_on_ground(args.on_ground);
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_POS: flatbuffers::VOffsetT = 6;
    pub const VT_MOTION: flatbuffers::VOffsetT = 8;
    pub const VT_ROTATION: flatbuffers::VOffsetT = 10;
    pub const VT_FALL_DISTANCE: flatbuffers::VOffsetT = 12;
    pub const VT_FIRE: flatbuffers::VOffsetT = 14;
    pub const VT_AIR: flatbuffers::VOffsetT = 16;
    pub const VT_ON_GROUND: flatbuffers::VOffsetT = 18;
    pub const VT_NO_GRAVITY: flatbuffers::VOffsetT = 20;
    pub const VT_INVULNERABLE: flatbuffers::VOffsetT = 22;
    pub const VT_PORTAL_COOLDOWN: flatbuffers::VOffsetT = 24;
    pub const VT_UUID: flatbuffers::VOffsetT = 26;
    pub const VT_CUSTOM_NAME: flatbuffers::VOffsetT = 28;
    pub const VT_CUSTOM_NAME_VISIBLE: flatbuffers::VOffsetT = 30;
    pub const VT_SILENT: flatbuffers::VOffsetT = 32;
    pub const VT_GLOWING: flatbuffers::VOffsetT = 34;

  #[inline]
  pub fn id(&self) -> &'a str {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Entity::VT_ID, None).unwrap()
  }
  #[inline]
  pub fn pos(&self) -> &'a Vector3d {
    self._tab.get::<Vector3d>(Entity::VT_POS, None).unwrap()
  }
  #[inline]
  pub fn motion(&self) -> &'a Vector3d {
    self._tab.get::<Vector3d>(Entity::VT_MOTION, None).unwrap()
  }
  #[inline]
  pub fn rotation(&self) -> &'a Vector2f {
    self._tab.get::<Vector2f>(Entity::VT_ROTATION, None).unwrap()
  }
  #[inline]
  pub fn fall_distance(&self) -> f32 {
    self._tab.get::<f32>(Entity::VT_FALL_DISTANCE, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn fire(&self) -> u16 {
    self._tab.get::<u16>(Entity::VT_FIRE, Some(0)).unwrap()
  }
  #[inline]
  pub fn air(&self) -> u16 {
    self._tab.get::<u16>(Entity::VT_AIR, Some(0)).unwrap()
  }
  #[inline]
  pub fn on_ground(&self) -> bool {
    self._tab.get::<bool>(Entity::VT_ON_GROUND, Some(false)).unwrap()
  }
  #[inline]
  pub fn no_gravity(&self) -> bool {
    self._tab.get::<bool>(Entity::VT_NO_GRAVITY, Some(false)).unwrap()
  }
  #[inline]
  pub fn invulnerable(&self) -> bool {
    self._tab.get::<bool>(Entity::VT_INVULNERABLE, Some(false)).unwrap()
  }
  #[inline]
  pub fn portal_cooldown(&self) -> i32 {
    self._tab.get::<i32>(Entity::VT_PORTAL_COOLDOWN, Some(0)).unwrap()
  }
  #[inline]
  pub fn uuid(&self) -> &'a Uuid {
    self._tab.get::<Uuid>(Entity::VT_UUID, None).unwrap()
  }
  #[inline]
  pub fn custom_name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Entity::VT_CUSTOM_NAME, None)
  }
  #[inline]
  pub fn custom_name_visible(&self) -> bool {
    self._tab.get::<bool>(Entity::VT_CUSTOM_NAME_VISIBLE, Some(false)).unwrap()
  }
  #[inline]
  pub fn silent(&self) -> bool {
    self._tab.get::<bool>(Entity::VT_SILENT, Some(false)).unwrap()
  }
  #[inline]
  pub fn glowing(&self) -> bool {
    self._tab.get::<bool>(Entity::VT_GLOWING, Some(false)).unwrap()
  }
}

pub struct EntityArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub pos: Option<&'a  Vector3d>,
    pub motion: Option<&'a  Vector3d>,
    pub rotation: Option<&'a  Vector2f>,
    pub fall_distance: f32,
    pub fire: u16,
    pub air: u16,
    pub on_ground: bool,
    pub no_gravity: bool,
    pub invulnerable: bool,
    pub portal_cooldown: i32,
    pub uuid: Option<&'a  Uuid>,
    pub custom_name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub custom_name_visible: bool,
    pub silent: bool,
    pub glowing: bool,
}
impl<'a> Default for EntityArgs<'a> {
    #[inline]
    fn default() -> Self {
        EntityArgs {
            id: None, // required field
            pos: None, // required field
            motion: None, // required field
            rotation: None, // required field
            fall_distance: 0.0,
            fire: 0,
            air: 0,
            on_ground: false,
            no_gravity: false,
            invulnerable: false,
            portal_cooldown: 0,
            uuid: None, // required field
            custom_name: None,
            custom_name_visible: false,
            silent: false,
            glowing: false,
        }
    }
}
pub struct EntityBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EntityBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Entity::VT_ID, id);
  }
  #[inline]
  pub fn add_pos(&mut self, pos: &'b  Vector3d) {
    self.fbb_.push_slot_always::<&Vector3d>(Entity::VT_POS, pos);
  }
  #[inline]
  pub fn add_motion(&mut self, motion: &'b  Vector3d) {
    self.fbb_.push_slot_always::<&Vector3d>(Entity::VT_MOTION, motion);
  }
  #[inline]
  pub fn add_rotation(&mut self, rotation: &'b  Vector2f) {
    self.fbb_.push_slot_always::<&Vector2f>(Entity::VT_ROTATION, rotation);
  }
  #[inline]
  pub fn add_fall_distance(&mut self, fall_distance: f32) {
    self.fbb_.push_slot::<f32>(Entity::VT_FALL_DISTANCE, fall_distance, 0.0);
  }
  #[inline]
  pub fn add_fire(&mut self, fire: u16) {
    self.fbb_.push_slot::<u16>(Entity::VT_FIRE, fire, 0);
  }
  #[inline]
  pub fn add_air(&mut self, air: u16) {
    self.fbb_.push_slot::<u16>(Entity::VT_AIR, air, 0);
  }
  #[inline]
  pub fn add_on_ground(&mut self, on_ground: bool) {
    self.fbb_.push_slot::<bool>(Entity::VT_ON_GROUND, on_ground, false);
  }
  #[inline]
  pub fn add_no_gravity(&mut self, no_gravity: bool) {
    self.fbb_.push_slot::<bool>(Entity::VT_NO_GRAVITY, no_gravity, false);
  }
  #[inline]
  pub fn add_invulnerable(&mut self, invulnerable: bool) {
    self.fbb_.push_slot::<bool>(Entity::VT_INVULNERABLE, invulnerable, false);
  }
  #[inline]
  pub fn add_portal_cooldown(&mut self, portal_cooldown: i32) {
    self.fbb_.push_slot::<i32>(Entity::VT_PORTAL_COOLDOWN, portal_cooldown, 0);
  }
  #[inline]
  pub fn add_uuid(&mut self, uuid: &'b  Uuid) {
    self.fbb_.push_slot_always::<&Uuid>(Entity::VT_UUID, uuid);
  }
  #[inline]
  pub fn add_custom_name(&mut self, custom_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Entity::VT_CUSTOM_NAME, custom_name);
  }
  #[inline]
  pub fn add_custom_name_visible(&mut self, custom_name_visible: bool) {
    self.fbb_.push_slot::<bool>(Entity::VT_CUSTOM_NAME_VISIBLE, custom_name_visible, false);
  }
  #[inline]
  pub fn add_silent(&mut self, silent: bool) {
    self.fbb_.push_slot::<bool>(Entity::VT_SILENT, silent, false);
  }
  #[inline]
  pub fn add_glowing(&mut self, glowing: bool) {
    self.fbb_.push_slot::<bool>(Entity::VT_GLOWING, glowing, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EntityBuilder<'a, 'b> {
    let start = _fbb.start_table();
    EntityBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Entity<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Entity::VT_ID,"id");
    self.fbb_.required(o, Entity::VT_POS,"pos");
    self.fbb_.required(o, Entity::VT_MOTION,"motion");
    self.fbb_.required(o, Entity::VT_ROTATION,"rotation");
    self.fbb_.required(o, Entity::VT_UUID,"uuid");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum RecipeBookOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct RecipeBook<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RecipeBook<'a> {
    type Inner = RecipeBook<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> RecipeBook<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RecipeBook {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RecipeBookArgs<'args>) -> flatbuffers::WIPOffset<RecipeBook<'bldr>> {
      let mut builder = RecipeBookBuilder::new(_fbb);
      if let Some(x) = args.to_be_displayed { builder.add_to_be_displayed(x); }
      if let Some(x) = args.recipes { builder.add_recipes(x); }
      builder.add_is_smoker_gui_open(args.is_smoker_gui_open);
      builder.add_is_smoker_filtering_craftable(args.is_smoker_filtering_craftable);
      builder.add_is_blasting_furnace_gui_open(args.is_blasting_furnace_gui_open);
      builder.add_is_blasting_furnace_filtering_craftable(args.is_blasting_furnace_filtering_craftable);
      builder.add_is_furnace_gui_open(args.is_furnace_gui_open);
      builder.add_is_furnace_filtering_craftable(args.is_furnace_filtering_craftable);
      builder.add_is_gui_open(args.is_gui_open);
      builder.add_is_filtering_craftable(args.is_filtering_craftable);
      builder.finish()
    }

    pub const VT_RECIPES: flatbuffers::VOffsetT = 4;
    pub const VT_TO_BE_DISPLAYED: flatbuffers::VOffsetT = 6;
    pub const VT_IS_FILTERING_CRAFTABLE: flatbuffers::VOffsetT = 8;
    pub const VT_IS_GUI_OPEN: flatbuffers::VOffsetT = 10;
    pub const VT_IS_FURNACE_FILTERING_CRAFTABLE: flatbuffers::VOffsetT = 12;
    pub const VT_IS_FURNACE_GUI_OPEN: flatbuffers::VOffsetT = 14;
    pub const VT_IS_BLASTING_FURNACE_FILTERING_CRAFTABLE: flatbuffers::VOffsetT = 16;
    pub const VT_IS_BLASTING_FURNACE_GUI_OPEN: flatbuffers::VOffsetT = 18;
    pub const VT_IS_SMOKER_FILTERING_CRAFTABLE: flatbuffers::VOffsetT = 20;
    pub const VT_IS_SMOKER_GUI_OPEN: flatbuffers::VOffsetT = 22;

  #[inline]
  pub fn recipes(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>>>(RecipeBook::VT_RECIPES, None).unwrap()
  }
  #[inline]
  pub fn to_be_displayed(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<&'a str>>>>(RecipeBook::VT_TO_BE_DISPLAYED, None).unwrap()
  }
  #[inline]
  pub fn is_filtering_craftable(&self) -> bool {
    self._tab.get::<bool>(RecipeBook::VT_IS_FILTERING_CRAFTABLE, Some(false)).unwrap()
  }
  #[inline]
  pub fn is_gui_open(&self) -> bool {
    self._tab.get::<bool>(RecipeBook::VT_IS_GUI_OPEN, Some(false)).unwrap()
  }
  #[inline]
  pub fn is_furnace_filtering_craftable(&self) -> bool {
    self._tab.get::<bool>(RecipeBook::VT_IS_FURNACE_FILTERING_CRAFTABLE, Some(false)).unwrap()
  }
  #[inline]
  pub fn is_furnace_gui_open(&self) -> bool {
    self._tab.get::<bool>(RecipeBook::VT_IS_FURNACE_GUI_OPEN, Some(false)).unwrap()
  }
  #[inline]
  pub fn is_blasting_furnace_filtering_craftable(&self) -> bool {
    self._tab.get::<bool>(RecipeBook::VT_IS_BLASTING_FURNACE_FILTERING_CRAFTABLE, Some(false)).unwrap()
  }
  #[inline]
  pub fn is_blasting_furnace_gui_open(&self) -> bool {
    self._tab.get::<bool>(RecipeBook::VT_IS_BLASTING_FURNACE_GUI_OPEN, Some(false)).unwrap()
  }
  #[inline]
  pub fn is_smoker_filtering_craftable(&self) -> bool {
    self._tab.get::<bool>(RecipeBook::VT_IS_SMOKER_FILTERING_CRAFTABLE, Some(false)).unwrap()
  }
  #[inline]
  pub fn is_smoker_gui_open(&self) -> bool {
    self._tab.get::<bool>(RecipeBook::VT_IS_SMOKER_GUI_OPEN, Some(false)).unwrap()
  }
}

pub struct RecipeBookArgs<'a> {
    pub recipes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<&'a  str>>>>,
    pub to_be_displayed: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<&'a  str>>>>,
    pub is_filtering_craftable: bool,
    pub is_gui_open: bool,
    pub is_furnace_filtering_craftable: bool,
    pub is_furnace_gui_open: bool,
    pub is_blasting_furnace_filtering_craftable: bool,
    pub is_blasting_furnace_gui_open: bool,
    pub is_smoker_filtering_craftable: bool,
    pub is_smoker_gui_open: bool,
}
impl<'a> Default for RecipeBookArgs<'a> {
    #[inline]
    fn default() -> Self {
        RecipeBookArgs {
            recipes: None, // required field
            to_be_displayed: None, // required field
            is_filtering_craftable: false,
            is_gui_open: false,
            is_furnace_filtering_craftable: false,
            is_furnace_gui_open: false,
            is_blasting_furnace_filtering_craftable: false,
            is_blasting_furnace_gui_open: false,
            is_smoker_filtering_craftable: false,
            is_smoker_gui_open: false,
        }
    }
}
pub struct RecipeBookBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RecipeBookBuilder<'a, 'b> {
  #[inline]
  pub fn add_recipes(&mut self, recipes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RecipeBook::VT_RECIPES, recipes);
  }
  #[inline]
  pub fn add_to_be_displayed(&mut self, to_be_displayed: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RecipeBook::VT_TO_BE_DISPLAYED, to_be_displayed);
  }
  #[inline]
  pub fn add_is_filtering_craftable(&mut self, is_filtering_craftable: bool) {
    self.fbb_.push_slot::<bool>(RecipeBook::VT_IS_FILTERING_CRAFTABLE, is_filtering_craftable, false);
  }
  #[inline]
  pub fn add_is_gui_open(&mut self, is_gui_open: bool) {
    self.fbb_.push_slot::<bool>(RecipeBook::VT_IS_GUI_OPEN, is_gui_open, false);
  }
  #[inline]
  pub fn add_is_furnace_filtering_craftable(&mut self, is_furnace_filtering_craftable: bool) {
    self.fbb_.push_slot::<bool>(RecipeBook::VT_IS_FURNACE_FILTERING_CRAFTABLE, is_furnace_filtering_craftable, false);
  }
  #[inline]
  pub fn add_is_furnace_gui_open(&mut self, is_furnace_gui_open: bool) {
    self.fbb_.push_slot::<bool>(RecipeBook::VT_IS_FURNACE_GUI_OPEN, is_furnace_gui_open, false);
  }
  #[inline]
  pub fn add_is_blasting_furnace_filtering_craftable(&mut self, is_blasting_furnace_filtering_craftable: bool) {
    self.fbb_.push_slot::<bool>(RecipeBook::VT_IS_BLASTING_FURNACE_FILTERING_CRAFTABLE, is_blasting_furnace_filtering_craftable, false);
  }
  #[inline]
  pub fn add_is_blasting_furnace_gui_open(&mut self, is_blasting_furnace_gui_open: bool) {
    self.fbb_.push_slot::<bool>(RecipeBook::VT_IS_BLASTING_FURNACE_GUI_OPEN, is_blasting_furnace_gui_open, false);
  }
  #[inline]
  pub fn add_is_smoker_filtering_craftable(&mut self, is_smoker_filtering_craftable: bool) {
    self.fbb_.push_slot::<bool>(RecipeBook::VT_IS_SMOKER_FILTERING_CRAFTABLE, is_smoker_filtering_craftable, false);
  }
  #[inline]
  pub fn add_is_smoker_gui_open(&mut self, is_smoker_gui_open: bool) {
    self.fbb_.push_slot::<bool>(RecipeBook::VT_IS_SMOKER_GUI_OPEN, is_smoker_gui_open, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RecipeBookBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RecipeBookBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RecipeBook<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, RecipeBook::VT_RECIPES,"recipes");
    self.fbb_.required(o, RecipeBook::VT_TO_BE_DISPLAYED,"to_be_displayed");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum VehicleOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Vehicle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Vehicle<'a> {
    type Inner = Vehicle<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Vehicle<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Vehicle {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args VehicleArgs<'args>) -> flatbuffers::WIPOffset<Vehicle<'bldr>> {
      let mut builder = VehicleBuilder::new(_fbb);
      if let Some(x) = args.entity { builder.add_entity(x); }
      builder.add_param_3(args.param_3);
      builder.add_param_2(args.param_2);
      builder.add_param_1(args.param_1);
      builder.add_param_0(args.param_0);
      builder.finish()
    }

    pub const VT_PARAM_0: flatbuffers::VOffsetT = 4;
    pub const VT_PARAM_1: flatbuffers::VOffsetT = 6;
    pub const VT_PARAM_2: flatbuffers::VOffsetT = 8;
    pub const VT_PARAM_3: flatbuffers::VOffsetT = 10;
    pub const VT_ENTITY: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn param_0(&self) -> u32 {
    self._tab.get::<u32>(Vehicle::VT_PARAM_0, Some(0)).unwrap()
  }
  #[inline]
  pub fn param_1(&self) -> u32 {
    self._tab.get::<u32>(Vehicle::VT_PARAM_1, Some(0)).unwrap()
  }
  #[inline]
  pub fn param_2(&self) -> u32 {
    self._tab.get::<u32>(Vehicle::VT_PARAM_2, Some(0)).unwrap()
  }
  #[inline]
  pub fn param_3(&self) -> u32 {
    self._tab.get::<u32>(Vehicle::VT_PARAM_3, Some(0)).unwrap()
  }
  #[inline]
  pub fn entity(&self) -> Entity<'a> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Entity<'a>>>(Vehicle::VT_ENTITY, None).unwrap()
  }
}

pub struct VehicleArgs<'a> {
    pub param_0: u32,
    pub param_1: u32,
    pub param_2: u32,
    pub param_3: u32,
    pub entity: Option<flatbuffers::WIPOffset<Entity<'a >>>,
}
impl<'a> Default for VehicleArgs<'a> {
    #[inline]
    fn default() -> Self {
        VehicleArgs {
            param_0: 0,
            param_1: 0,
            param_2: 0,
            param_3: 0,
            entity: None, // required field
        }
    }
}
pub struct VehicleBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> VehicleBuilder<'a, 'b> {
  #[inline]
  pub fn add_param_0(&mut self, param_0: u32) {
    self.fbb_.push_slot::<u32>(Vehicle::VT_PARAM_0, param_0, 0);
  }
  #[inline]
  pub fn add_param_1(&mut self, param_1: u32) {
    self.fbb_.push_slot::<u32>(Vehicle::VT_PARAM_1, param_1, 0);
  }
  #[inline]
  pub fn add_param_2(&mut self, param_2: u32) {
    self.fbb_.push_slot::<u32>(Vehicle::VT_PARAM_2, param_2, 0);
  }
  #[inline]
  pub fn add_param_3(&mut self, param_3: u32) {
    self.fbb_.push_slot::<u32>(Vehicle::VT_PARAM_3, param_3, 0);
  }
  #[inline]
  pub fn add_entity(&mut self, entity: flatbuffers::WIPOffset<Entity<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Entity>>(Vehicle::VT_ENTITY, entity);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> VehicleBuilder<'a, 'b> {
    let start = _fbb.start_table();
    VehicleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Vehicle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Vehicle::VT_ENTITY,"entity");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum PlayerOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Player<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Player<'a> {
    type Inner = Player<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Player<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Player {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args PlayerArgs<'args>) -> flatbuffers::WIPOffset<Player<'bldr>> {
      let mut builder = PlayerBuilder::new(_fbb);
      builder.add_spawn_z(args.spawn_z);
      builder.add_spawn_y(args.spawn_y);
      builder.add_spawn_x(args.spawn_x);
      builder.add_score(args.score);
      if let Some(x) = args.recipe_book { builder.add_recipe_book(x); }
      if let Some(x) = args.shoulder_entity_right { builder.add_shoulder_entity_right(x); }
      if let Some(x) = args.shoulder_entity_left { builder.add_shoulder_entity_left(x); }
      if let Some(x) = args.root_vehicle { builder.add_root_vehicle(x); }
      if let Some(x) = args.entered_nether_position { builder.add_entered_nether_position(x); }
      if let Some(x) = args.abilities { builder.add_abilities(x); }
      if let Some(x) = args.ender_items { builder.add_ender_items(x); }
      if let Some(x) = args.inventory { builder.add_inventory(x); }
      builder.add_xp_seed(args.xp_seed);
      builder.add_xp_total(args.xp_total);
      builder.add_xp_p(args.xp_p);
      builder.add_xp_level(args.xp_level);
      builder.add_food_tick_timer(args.food_tick_timer);
      builder.add_food_saturation_level(args.food_saturation_level);
      builder.add_food_exhaustion_level(args.food_exhaustion_level);
      if let Some(x) = args.spawn_dimension { builder.add_spawn_dimension(x); }
      if let Some(x) = args.selected_item { builder.add_selected_item(x); }
      builder.add_selected_item_slot(args.selected_item_slot);
      if let Some(x) = args.dimension { builder.add_dimension(x); }
      builder.add_sleep_timer(args.sleep_timer);
      builder.add_seen_credits(args.seen_credits);
      builder.add_spawn_forced(args.spawn_forced);
      builder.add_previous_game_type(args.previous_game_type);
      builder.add_game_type(args.game_type);
      builder.finish()
    }

    pub const VT_GAME_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_PREVIOUS_GAME_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_SCORE: flatbuffers::VOffsetT = 8;
    pub const VT_DIMENSION: flatbuffers::VOffsetT = 10;
    pub const VT_SELECTED_ITEM_SLOT: flatbuffers::VOffsetT = 12;
    pub const VT_SELECTED_ITEM: flatbuffers::VOffsetT = 14;
    pub const VT_SPAWN_DIMENSION: flatbuffers::VOffsetT = 16;
    pub const VT_SPAWN_X: flatbuffers::VOffsetT = 18;
    pub const VT_SPAWN_Y: flatbuffers::VOffsetT = 20;
    pub const VT_SPAWN_Z: flatbuffers::VOffsetT = 22;
    pub const VT_SPAWN_FORCED: flatbuffers::VOffsetT = 24;
    pub const VT_SLEEP_TIMER: flatbuffers::VOffsetT = 26;
    pub const VT_FOOD_EXHAUSTION_LEVEL: flatbuffers::VOffsetT = 28;
    pub const VT_FOOD_SATURATION_LEVEL: flatbuffers::VOffsetT = 30;
    pub const VT_FOOD_TICK_TIMER: flatbuffers::VOffsetT = 32;
    pub const VT_XP_LEVEL: flatbuffers::VOffsetT = 34;
    pub const VT_XP_P: flatbuffers::VOffsetT = 36;
    pub const VT_XP_TOTAL: flatbuffers::VOffsetT = 38;
    pub const VT_XP_SEED: flatbuffers::VOffsetT = 40;
    pub const VT_INVENTORY: flatbuffers::VOffsetT = 42;
    pub const VT_ENDER_ITEMS: flatbuffers::VOffsetT = 44;
    pub const VT_ABILITIES: flatbuffers::VOffsetT = 46;
    pub const VT_ENTERED_NETHER_POSITION: flatbuffers::VOffsetT = 48;
    pub const VT_ROOT_VEHICLE: flatbuffers::VOffsetT = 50;
    pub const VT_SHOULDER_ENTITY_LEFT: flatbuffers::VOffsetT = 52;
    pub const VT_SHOULDER_ENTITY_RIGHT: flatbuffers::VOffsetT = 54;
    pub const VT_SEEN_CREDITS: flatbuffers::VOffsetT = 56;
    pub const VT_RECIPE_BOOK: flatbuffers::VOffsetT = 58;

  #[inline]
  pub fn game_type(&self) -> GameType {
    self._tab.get::<GameType>(Player::VT_GAME_TYPE, Some(GameType::Survival)).unwrap()
  }
  #[inline]
  pub fn previous_game_type(&self) -> GameType {
    self._tab.get::<GameType>(Player::VT_PREVIOUS_GAME_TYPE, Some(GameType::Survival)).unwrap()
  }
  #[inline]
  pub fn score(&self) -> u64 {
    self._tab.get::<u64>(Player::VT_SCORE, Some(0)).unwrap()
  }
  #[inline]
  pub fn dimension(&self) -> &'a str {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Player::VT_DIMENSION, None).unwrap()
  }
  #[inline]
  pub fn selected_item_slot(&self) -> u32 {
    self._tab.get::<u32>(Player::VT_SELECTED_ITEM_SLOT, Some(0)).unwrap()
  }
  #[inline]
  pub fn selected_item(&self) -> Item<'a> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Item<'a>>>(Player::VT_SELECTED_ITEM, None).unwrap()
  }
  #[inline]
  pub fn spawn_dimension(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Player::VT_SPAWN_DIMENSION, None)
  }
  #[inline]
  pub fn spawn_x(&self) -> i64 {
    self._tab.get::<i64>(Player::VT_SPAWN_X, Some(0)).unwrap()
  }
  #[inline]
  pub fn spawn_y(&self) -> i64 {
    self._tab.get::<i64>(Player::VT_SPAWN_Y, Some(0)).unwrap()
  }
  #[inline]
  pub fn spawn_z(&self) -> i64 {
    self._tab.get::<i64>(Player::VT_SPAWN_Z, Some(0)).unwrap()
  }
  #[inline]
  pub fn spawn_forced(&self) -> bool {
    self._tab.get::<bool>(Player::VT_SPAWN_FORCED, Some(false)).unwrap()
  }
  #[inline]
  pub fn sleep_timer(&self) -> u16 {
    self._tab.get::<u16>(Player::VT_SLEEP_TIMER, Some(0)).unwrap()
  }
  #[inline]
  pub fn food_exhaustion_level(&self) -> f32 {
    self._tab.get::<f32>(Player::VT_FOOD_EXHAUSTION_LEVEL, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn food_saturation_level(&self) -> f32 {
    self._tab.get::<f32>(Player::VT_FOOD_SATURATION_LEVEL, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn food_tick_timer(&self) -> u32 {
    self._tab.get::<u32>(Player::VT_FOOD_TICK_TIMER, Some(0)).unwrap()
  }
  #[inline]
  pub fn xp_level(&self) -> u32 {
    self._tab.get::<u32>(Player::VT_XP_LEVEL, Some(0)).unwrap()
  }
  #[inline]
  pub fn xp_p(&self) -> f32 {
    self._tab.get::<f32>(Player::VT_XP_P, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn xp_total(&self) -> i32 {
    self._tab.get::<i32>(Player::VT_XP_TOTAL, Some(0)).unwrap()
  }
  #[inline]
  pub fn xp_seed(&self) -> i32 {
    self._tab.get::<i32>(Player::VT_XP_SEED, Some(0)).unwrap()
  }
  #[inline]
  pub fn inventory(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Item<'a>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Item<'a>>>>>(Player::VT_INVENTORY, None).unwrap()
  }
  #[inline]
  pub fn ender_items(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Item<'a>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Item<'a>>>>>(Player::VT_ENDER_ITEMS, None).unwrap()
  }
  #[inline]
  pub fn abilities(&self) -> &'a Abilities {
    self._tab.get::<Abilities>(Player::VT_ABILITIES, None).unwrap()
  }
  #[inline]
  pub fn entered_nether_position(&self) -> Option<&'a Vector3d> {
    self._tab.get::<Vector3d>(Player::VT_ENTERED_NETHER_POSITION, None)
  }
  #[inline]
  pub fn root_vehicle(&self) -> Option<Vehicle<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Vehicle<'a>>>(Player::VT_ROOT_VEHICLE, None)
  }
  #[inline]
  pub fn shoulder_entity_left(&self) -> Option<Entity<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Entity<'a>>>(Player::VT_SHOULDER_ENTITY_LEFT, None)
  }
  #[inline]
  pub fn shoulder_entity_right(&self) -> Option<Entity<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Entity<'a>>>(Player::VT_SHOULDER_ENTITY_RIGHT, None)
  }
  #[inline]
  pub fn seen_credits(&self) -> bool {
    self._tab.get::<bool>(Player::VT_SEEN_CREDITS, Some(false)).unwrap()
  }
  #[inline]
  pub fn recipe_book(&self) -> RecipeBook<'a> {
    self._tab.get::<flatbuffers::ForwardsUOffset<RecipeBook<'a>>>(Player::VT_RECIPE_BOOK, None).unwrap()
  }
}

pub struct PlayerArgs<'a> {
    pub game_type: GameType,
    pub previous_game_type: GameType,
    pub score: u64,
    pub dimension: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub selected_item_slot: u32,
    pub selected_item: Option<flatbuffers::WIPOffset<Item<'a >>>,
    pub spawn_dimension: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub spawn_x: i64,
    pub spawn_y: i64,
    pub spawn_z: i64,
    pub spawn_forced: bool,
    pub sleep_timer: u16,
    pub food_exhaustion_level: f32,
    pub food_saturation_level: f32,
    pub food_tick_timer: u32,
    pub xp_level: u32,
    pub xp_p: f32,
    pub xp_total: i32,
    pub xp_seed: i32,
    pub inventory: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Item<'a >>>>>,
    pub ender_items: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Item<'a >>>>>,
    pub abilities: Option<&'a  Abilities>,
    pub entered_nether_position: Option<&'a  Vector3d>,
    pub root_vehicle: Option<flatbuffers::WIPOffset<Vehicle<'a >>>,
    pub shoulder_entity_left: Option<flatbuffers::WIPOffset<Entity<'a >>>,
    pub shoulder_entity_right: Option<flatbuffers::WIPOffset<Entity<'a >>>,
    pub seen_credits: bool,
    pub recipe_book: Option<flatbuffers::WIPOffset<RecipeBook<'a >>>,
}
impl<'a> Default for PlayerArgs<'a> {
    #[inline]
    fn default() -> Self {
        PlayerArgs {
            game_type: GameType::Survival,
            previous_game_type: GameType::Survival,
            score: 0,
            dimension: None, // required field
            selected_item_slot: 0,
            selected_item: None, // required field
            spawn_dimension: None,
            spawn_x: 0,
            spawn_y: 0,
            spawn_z: 0,
            spawn_forced: false,
            sleep_timer: 0,
            food_exhaustion_level: 0.0,
            food_saturation_level: 0.0,
            food_tick_timer: 0,
            xp_level: 0,
            xp_p: 0.0,
            xp_total: 0,
            xp_seed: 0,
            inventory: None, // required field
            ender_items: None, // required field
            abilities: None, // required field
            entered_nether_position: None,
            root_vehicle: None,
            shoulder_entity_left: None,
            shoulder_entity_right: None,
            seen_credits: false,
            recipe_book: None, // required field
        }
    }
}
pub struct PlayerBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PlayerBuilder<'a, 'b> {
  #[inline]
  pub fn add_game_type(&mut self, game_type: GameType) {
    self.fbb_.push_slot::<GameType>(Player::VT_GAME_TYPE, game_type, GameType::Survival);
  }
  #[inline]
  pub fn add_previous_game_type(&mut self, previous_game_type: GameType) {
    self.fbb_.push_slot::<GameType>(Player::VT_PREVIOUS_GAME_TYPE, previous_game_type, GameType::Survival);
  }
  #[inline]
  pub fn add_score(&mut self, score: u64) {
    self.fbb_.push_slot::<u64>(Player::VT_SCORE, score, 0);
  }
  #[inline]
  pub fn add_dimension(&mut self, dimension: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Player::VT_DIMENSION, dimension);
  }
  #[inline]
  pub fn add_selected_item_slot(&mut self, selected_item_slot: u32) {
    self.fbb_.push_slot::<u32>(Player::VT_SELECTED_ITEM_SLOT, selected_item_slot, 0);
  }
  #[inline]
  pub fn add_selected_item(&mut self, selected_item: flatbuffers::WIPOffset<Item<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Item>>(Player::VT_SELECTED_ITEM, selected_item);
  }
  #[inline]
  pub fn add_spawn_dimension(&mut self, spawn_dimension: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Player::VT_SPAWN_DIMENSION, spawn_dimension);
  }
  #[inline]
  pub fn add_spawn_x(&mut self, spawn_x: i64) {
    self.fbb_.push_slot::<i64>(Player::VT_SPAWN_X, spawn_x, 0);
  }
  #[inline]
  pub fn add_spawn_y(&mut self, spawn_y: i64) {
    self.fbb_.push_slot::<i64>(Player::VT_SPAWN_Y, spawn_y, 0);
  }
  #[inline]
  pub fn add_spawn_z(&mut self, spawn_z: i64) {
    self.fbb_.push_slot::<i64>(Player::VT_SPAWN_Z, spawn_z, 0);
  }
  #[inline]
  pub fn add_spawn_forced(&mut self, spawn_forced: bool) {
    self.fbb_.push_slot::<bool>(Player::VT_SPAWN_FORCED, spawn_forced, false);
  }
  #[inline]
  pub fn add_sleep_timer(&mut self, sleep_timer: u16) {
    self.fbb_.push_slot::<u16>(Player::VT_SLEEP_TIMER, sleep_timer, 0);
  }
  #[inline]
  pub fn add_food_exhaustion_level(&mut self, food_exhaustion_level: f32) {
    self.fbb_.push_slot::<f32>(Player::VT_FOOD_EXHAUSTION_LEVEL, food_exhaustion_level, 0.0);
  }
  #[inline]
  pub fn add_food_saturation_level(&mut self, food_saturation_level: f32) {
    self.fbb_.push_slot::<f32>(Player::VT_FOOD_SATURATION_LEVEL, food_saturation_level, 0.0);
  }
  #[inline]
  pub fn add_food_tick_timer(&mut self, food_tick_timer: u32) {
    self.fbb_.push_slot::<u32>(Player::VT_FOOD_TICK_TIMER, food_tick_timer, 0);
  }
  #[inline]
  pub fn add_xp_level(&mut self, xp_level: u32) {
    self.fbb_.push_slot::<u32>(Player::VT_XP_LEVEL, xp_level, 0);
  }
  #[inline]
  pub fn add_xp_p(&mut self, xp_p: f32) {
    self.fbb_.push_slot::<f32>(Player::VT_XP_P, xp_p, 0.0);
  }
  #[inline]
  pub fn add_xp_total(&mut self, xp_total: i32) {
    self.fbb_.push_slot::<i32>(Player::VT_XP_TOTAL, xp_total, 0);
  }
  #[inline]
  pub fn add_xp_seed(&mut self, xp_seed: i32) {
    self.fbb_.push_slot::<i32>(Player::VT_XP_SEED, xp_seed, 0);
  }
  #[inline]
  pub fn add_inventory(&mut self, inventory: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Item<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Player::VT_INVENTORY, inventory);
  }
  #[inline]
  pub fn add_ender_items(&mut self, ender_items: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Item<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Player::VT_ENDER_ITEMS, ender_items);
  }
  #[inline]
  pub fn add_abilities(&mut self, abilities: &'b  Abilities) {
    self.fbb_.push_slot_always::<&Abilities>(Player::VT_ABILITIES, abilities);
  }
  #[inline]
  pub fn add_entered_nether_position(&mut self, entered_nether_position: &'b  Vector3d) {
    self.fbb_.push_slot_always::<&Vector3d>(Player::VT_ENTERED_NETHER_POSITION, entered_nether_position);
  }
  #[inline]
  pub fn add_root_vehicle(&mut self, root_vehicle: flatbuffers::WIPOffset<Vehicle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Vehicle>>(Player::VT_ROOT_VEHICLE, root_vehicle);
  }
  #[inline]
  pub fn add_shoulder_entity_left(&mut self, shoulder_entity_left: flatbuffers::WIPOffset<Entity<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Entity>>(Player::VT_SHOULDER_ENTITY_LEFT, shoulder_entity_left);
  }
  #[inline]
  pub fn add_shoulder_entity_right(&mut self, shoulder_entity_right: flatbuffers::WIPOffset<Entity<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Entity>>(Player::VT_SHOULDER_ENTITY_RIGHT, shoulder_entity_right);
  }
  #[inline]
  pub fn add_seen_credits(&mut self, seen_credits: bool) {
    self.fbb_.push_slot::<bool>(Player::VT_SEEN_CREDITS, seen_credits, false);
  }
  #[inline]
  pub fn add_recipe_book(&mut self, recipe_book: flatbuffers::WIPOffset<RecipeBook<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<RecipeBook>>(Player::VT_RECIPE_BOOK, recipe_book);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PlayerBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PlayerBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Player<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Player::VT_DIMENSION,"dimension");
    self.fbb_.required(o, Player::VT_SELECTED_ITEM,"selected_item");
    self.fbb_.required(o, Player::VT_INVENTORY,"inventory");
    self.fbb_.required(o, Player::VT_ENDER_ITEMS,"ender_items");
    self.fbb_.required(o, Player::VT_ABILITIES,"abilities");
    self.fbb_.required(o, Player::VT_RECIPE_BOOK,"recipe_book");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum PlayersOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Players<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Players<'a> {
    type Inner = Players<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Players<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Players {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args PlayersArgs<'args>) -> flatbuffers::WIPOffset<Players<'bldr>> {
      let mut builder = PlayersBuilder::new(_fbb);
      if let Some(x) = args.players { builder.add_players(x); }
      builder.finish()
    }

    pub const VT_PLAYERS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn players(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Player<'a>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Player<'a>>>>>(Players::VT_PLAYERS, None).unwrap()
  }
}

pub struct PlayersArgs<'a> {
    pub players: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Player<'a >>>>>,
}
impl<'a> Default for PlayersArgs<'a> {
    #[inline]
    fn default() -> Self {
        PlayersArgs {
            players: None, // required field
        }
    }
}
pub struct PlayersBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PlayersBuilder<'a, 'b> {
  #[inline]
  pub fn add_players(&mut self, players: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Player<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Players::VT_PLAYERS, players);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PlayersBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PlayersBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Players<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Players::VT_PLAYERS,"players");
    flatbuffers::WIPOffset::new(o.value())
  }
}

#[inline]
pub fn get_root_as_players<'a>(buf: &'a [u8]) -> Players<'a> {
  flatbuffers::get_root::<Players<'a>>(buf)
}

#[inline]
pub fn get_size_prefixed_root_as_players<'a>(buf: &'a [u8]) -> Players<'a> {
  flatbuffers::get_size_prefixed_root::<Players<'a>>(buf)
}

#[inline]
pub fn finish_players_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Players<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_players_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Players<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod minecraft_savedata

